/* soapC.c
   Generated by gSOAP 2.7.16 from sugar_soap.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "sugar_soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.16 2016-05-16 11:56:51 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships:
		return soap_in_ns1__get_USCOREmodified_USCORErelationships(soap, NULL, NULL, "ns1:get_modified_relationships");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse:
		return soap_in_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_modified_relationshipsResponse");
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities:
		return soap_in_ns1__get_USCOREupcoming_USCOREactivities(soap, NULL, NULL, "ns1:get_upcoming_activities");
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse:
		return soap_in_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, NULL, NULL, "ns1:get_upcoming_activitiesResponse");
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewed:
		return soap_in_ns1__get_USCORElast_USCOREviewed(soap, NULL, NULL, "ns1:get_last_viewed");
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse:
		return soap_in_ns1__get_USCORElast_USCOREviewedResponse(soap, NULL, NULL, "ns1:get_last_viewedResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5:
		return soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, NULL, NULL, "ns1:get_module_fields_md5");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		return soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, NULL, NULL, "ns1:get_module_fields_md5Response");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		return soap_in_ns1__get_USCOREentries_USCOREcount(soap, NULL, NULL, "ns1:get_entries_count");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		return soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, "ns1:get_entries_countResponse");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		return soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, NULL, NULL, "ns1:set_campaign_merge");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, NULL, NULL, "ns1:get_user_team_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, NULL, NULL, "ns1:get_user_team_idResponse");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		return soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, NULL, NULL, "ns1:get_available_modules");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		return soap_in_ns1__search_USCOREby_USCOREmodule(soap, NULL, NULL, "ns1:search_by_module");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		return soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		return soap_in_ns1__get_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:get_document_revision");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		return soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		return soap_in_ns1__set_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:set_document_revision");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		return soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		return soap_in_ns1__get_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:get_note_attachment");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		return soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		return soap_in_ns1__set_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:set_note_attachment");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		return soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		return soap_in_ns1__seamless_USCORElogin(soap, NULL, NULL, "ns1:seamless_login");
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		return soap_in_ns1__seamless_USCOREloginResponse(soap, NULL, NULL, "ns1:seamless_loginResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		return soap_in_ns1__get_USCOREmodule_USCOREfields(soap, NULL, NULL, "ns1:get_module_fields");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		return soap_in_ns1__get_USCOREuser_USCOREid(soap, NULL, NULL, "ns1:get_user_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		return soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, NULL, NULL, "ns1:get_user_idResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo:
		return soap_in_ns1__get_USCOREserver_USCOREinfo(soap, NULL, NULL, "ns1:get_server_info");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse:
		return soap_in_ns1__get_USCOREserver_USCOREinfoResponse(soap, NULL, NULL, "ns1:get_server_infoResponse");
	case SOAP_TYPE_ns1__set_USCOREentries:
		return soap_in_ns1__set_USCOREentries(soap, NULL, NULL, "ns1:set_entries");
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		return soap_in_ns1__set_USCOREentriesResponse(soap, NULL, NULL, "ns1:set_entriesResponse");
	case SOAP_TYPE_ns1__set_USCOREentry:
		return soap_in_ns1__set_USCOREentry(soap, NULL, NULL, "ns1:set_entry");
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		return soap_in_ns1__set_USCOREentryResponse(soap, NULL, NULL, "ns1:set_entryResponse");
	case SOAP_TYPE_ns1__get_USCORErelationships:
		return soap_in_ns1__get_USCORErelationships(soap, NULL, NULL, "ns1:get_relationships");
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		return soap_in_ns1__get_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationships:
		return soap_in_ns1__set_USCORErelationships(soap, NULL, NULL, "ns1:set_relationships");
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		return soap_in_ns1__set_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationship:
		return soap_in_ns1__set_USCORErelationship(soap, NULL, NULL, "ns1:set_relationship");
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		return soap_in_ns1__set_USCORErelationshipResponse(soap, NULL, NULL, "ns1:set_relationshipResponse");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		return soap_in_ns1__get_USCOREentry_USCORElist(soap, NULL, NULL, "ns1:get_entry_list");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		return soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, "ns1:get_entry_listResponse");
	case SOAP_TYPE_ns1__get_USCOREentries:
		return soap_in_ns1__get_USCOREentries(soap, NULL, NULL, "ns1:get_entries");
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		return soap_in_ns1__get_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_entriesResponse");
	case SOAP_TYPE_ns1__get_USCOREentry:
		return soap_in_ns1__get_USCOREentry(soap, NULL, NULL, "ns1:get_entry");
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		return soap_in_ns1__get_USCOREentryResponse(soap, NULL, NULL, "ns1:get_entryResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__login:
		return soap_in_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_in_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_report_USCOREentry_USCORElist:
		return soap_in_report_USCOREentry_USCORElist(soap, NULL, NULL, "ns1:entry_list2");
	case SOAP_TYPE_report_USCOREfield_USCORElist:
		return soap_in_report_USCOREfield_USCORElist(soap, NULL, NULL, "ns1:field_list2");
	case SOAP_TYPE_last_USCOREviewed_USCORElist:
		return soap_in_last_USCOREviewed_USCORElist(soap, NULL, NULL, "ns1:last_viewed_entry");
	case SOAP_TYPE_upcoming_USCOREactivities_USCORElist:
		return soap_in_upcoming_USCOREactivities_USCORElist(soap, NULL, NULL, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_module_USCOREnames:
		return soap_in_module_USCOREnames(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_md5_USCOREresults:
		return soap_in_md5_USCOREresults(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		return soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		return soap_in_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_deleted_USCOREarray:
		return soap_in_deleted_USCOREarray(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist:
		return soap_in_modified_USCORErelationship_USCOREentry_USCORElist(soap, NULL, NULL, "ns1:modified_relationship_entry");
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult:
		return soap_in_ns1__modified_USCORErelationship_USCOREresult(soap, NULL, NULL, "ns1:modified_relationship_result");
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry:
		return soap_in_ns1__modified_USCORErelationship_USCOREentry(soap, NULL, NULL, "ns1:modified_relationship_entry");
	case SOAP_TYPE_ns1__error_USCOREvalue:
		return soap_in_ns1__error_USCOREvalue(soap, NULL, NULL, "ns1:error_value");
	case SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist:
		return soap_in_search_USCORElink_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_in_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:search_link_name_value");
	case SOAP_TYPE_ns1__entry_USCORElist2:
		return soap_in_ns1__entry_USCORElist2(soap, NULL, NULL, "ns1:entry_list2");
	case SOAP_TYPE_ns1__field_USCORElist2:
		return soap_in_ns1__field_USCORElist2(soap, NULL, NULL, "ns1:field_list2");
	case SOAP_TYPE_link_USCOREvalue:
		return soap_in_link_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREvalue2:
		return soap_in_ns1__link_USCOREvalue2(soap, NULL, NULL, "ns1:link_value2");
	case SOAP_TYPE_link_USCORElist:
		return soap_in_link_USCORElist(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_ns1__link_USCORElist2:
		return soap_in_ns1__link_USCORElist2(soap, NULL, NULL, "ns1:link_list2");
	case SOAP_TYPE_ns1__acl_USCORElist_USCOREentry:
		return soap_in_ns1__acl_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:acl_list_entry");
	case SOAP_TYPE_acl_USCORElist:
		return soap_in_acl_USCORElist(soap, NULL, NULL, "ns1:acl_list_entry");
	case SOAP_TYPE_ns1__module_USCORElist_USCOREentry:
		return soap_in_ns1__module_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:module_list_entry");
	case SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry:
		return soap_in_ns1__last_USCOREviewed_USCOREentry(soap, NULL, NULL, "ns1:last_viewed_entry");
	case SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry:
		return soap_in_ns1__upcoming_USCOREactivity_USCOREentry(soap, NULL, NULL, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, "ns1:get_entries_count_result");
	case SOAP_TYPE_module_USCORElist_USCOREarray:
		return soap_in_module_USCORElist_USCOREarray(soap, NULL, NULL, "ns1:module_list_entry");
	case SOAP_TYPE_ns1__module_USCORElist:
		return soap_in_ns1__module_USCORElist(soap, NULL, NULL, "ns1:module_list");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:new_return_document_revision");
	case SOAP_TYPE_ns1__document_USCORErevision:
		return soap_in_ns1__document_USCORErevision(soap, NULL, NULL, "ns1:document_revision");
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, NULL, NULL, "ns1:new_set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:new_set_entry_result");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, NULL, NULL, "ns1:get_server_info_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_search_USCORElink_USCORElist:
		return soap_in_search_USCORElink_USCORElist(soap, NULL, NULL, "ns1:search_link_name_value");
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		return soap_in_ns1__return_USCOREsearch_USCOREresult(soap, NULL, NULL, "ns1:return_search_result");
	case SOAP_TYPE_link_USCORElists:
		return soap_in_link_USCORElists(soap, NULL, NULL, "ns1:link_list2");
	case SOAP_TYPE_entry_USCORElist:
		return soap_in_entry_USCORElist(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_result_version2");
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		return soap_in_link_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:link_value2");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		return soap_in_ns1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_select_USCOREfields:
		return soap_in_select_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		return soap_in_name_USCOREvalue_USCORElists(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, NULL, NULL, "ns1:set_entries_detail_result");
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		return soap_in_ns1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		return soap_in_link_USCOREfield_USCORElist(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_field_USCORElist:
		return soap_in_field_USCORElist(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		return soap_in_ns1__new_USCOREmodule_USCOREfields(soap, NULL, NULL, "ns1:new_module_fields");
	case SOAP_TYPE_ns1__name_USCOREvalue:
		return soap_in_ns1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREfield:
		return soap_in_ns1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		return soap_in_name_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__field:
		return soap_in_ns1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_ns1__user_USCOREauth:
		return soap_in_ns1__user_USCOREauth(soap, NULL, NULL, "ns1:user_auth");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		return soap_in_ns1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_note_attachment");
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse:
		return soap_in_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_modified_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREresult:
		return soap_in_PointerTons1__modified_USCORErelationship_USCOREresult(soap, NULL, NULL, "ns1:modified_relationship_result");
	case SOAP_TYPE_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse:
		return soap_in_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(soap, NULL, NULL, "ns1:get_upcoming_activitiesResponse");
	case SOAP_TYPE_PointerToupcoming_USCOREactivities_USCORElist:
		return soap_in_PointerToupcoming_USCOREactivities_USCORElist(soap, NULL, NULL, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerTons1__get_USCORElast_USCOREviewedResponse:
		return soap_in_PointerTons1__get_USCORElast_USCOREviewedResponse(soap, NULL, NULL, "ns1:get_last_viewedResponse");
	case SOAP_TYPE_PointerTomodule_USCOREnames:
		return soap_in_PointerTomodule_USCOREnames(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTolast_USCOREviewed_USCORElist:
		return soap_in_PointerTolast_USCOREviewed_USCORElist(soap, NULL, NULL, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		return soap_in_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, NULL, NULL, "ns1:get_module_fields_md5Response");
	case SOAP_TYPE_PointerTomd5_USCOREresults:
		return soap_in_PointerTomd5_USCOREresults(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		return soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, "ns1:get_entries_countResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, "ns1:get_entries_count_result");
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		return soap_in_PointerTons1__module_USCORElist(soap, NULL, NULL, "ns1:module_list");
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		return soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREsearch_USCOREresult:
		return soap_in_PointerTons1__return_USCOREsearch_USCOREresult(soap, NULL, NULL, "ns1:return_search_result");
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		return soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_in_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:new_return_document_revision");
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		return soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		return soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_in_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_return_note_attachment");
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		return soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREmodule_USCOREfields:
		return soap_in_PointerTons1__new_USCOREmodule_USCOREfields(soap, NULL, NULL, "ns1:new_module_fields");
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfoResponse:
		return soap_in_PointerTons1__get_USCOREserver_USCOREinfoResponse(soap, NULL, NULL, "ns1:get_server_infoResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_in_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, NULL, NULL, "ns1:get_server_info_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		return soap_in_PointerTons1__set_USCOREentriesResponse(soap, NULL, NULL, "ns1:set_entriesResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_in_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, NULL, NULL, "ns1:new_set_entries_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		return soap_in_PointerTons1__set_USCOREentryResponse(soap, NULL, NULL, "ns1:set_entryResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:new_set_entry_result");
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		return soap_in_PointerTons1__get_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		return soap_in_PointerTons1__set_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_PointerTodeleted_USCOREarray:
		return soap_in_PointerTodeleted_USCOREarray(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTonew_USCOREset_USCORErelationhip_USCOREids:
		return soap_in_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		return soap_in_PointerTons1__set_USCORErelationshipResponse(soap, NULL, NULL, "ns1:set_relationshipResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_in_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		return soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, "ns1:get_entry_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		return soap_in_PointerTons1__get_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_entriesResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		return soap_in_PointerTons1__get_USCOREentryResponse(soap, NULL, NULL, "ns1:get_entryResponse");
	case SOAP_TYPE_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		return soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_result_version2");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_in_PointerTons1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_in_PointerTons1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		return soap_in_PointerTons1__user_USCOREauth(soap, NULL, NULL, "ns1:user_auth");
	case SOAP_TYPE_PointerToPointerTons1__modified_USCORErelationship_USCOREentry:
		return soap_in_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(soap, NULL, NULL, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry:
		return soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(soap, NULL, NULL, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		return soap_in_PointerToPointerTolink_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_in_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCORElist2:
		return soap_in_PointerToPointerTons1__entry_USCORElist2(soap, NULL, NULL, "ns1:entry_list2");
	case SOAP_TYPE_PointerTons1__entry_USCORElist2:
		return soap_in_PointerTons1__entry_USCORElist2(soap, NULL, NULL, "ns1:entry_list2");
	case SOAP_TYPE_PointerToPointerTons1__field_USCORElist2:
		return soap_in_PointerToPointerTons1__field_USCORElist2(soap, NULL, NULL, "ns1:field_list2");
	case SOAP_TYPE_PointerTons1__field_USCORElist2:
		return soap_in_PointerTons1__field_USCORElist2(soap, NULL, NULL, "ns1:field_list2");
	case SOAP_TYPE_PointerToPointerTons1__acl_USCORElist_USCOREentry:
		return soap_in_PointerToPointerTons1__acl_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry:
		return soap_in_PointerTons1__acl_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerToPointerTons1__module_USCORElist_USCOREentry:
		return soap_in_PointerToPointerTons1__module_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:module_list_entry");
	case SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry:
		return soap_in_PointerTons1__module_USCORElist_USCOREentry(soap, NULL, NULL, "ns1:module_list_entry");
	case SOAP_TYPE_PointerToPointerTons1__last_USCOREviewed_USCOREentry:
		return soap_in_PointerToPointerTons1__last_USCOREviewed_USCOREentry(soap, NULL, NULL, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry:
		return soap_in_PointerTons1__last_USCOREviewed_USCOREentry(soap, NULL, NULL, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry:
		return soap_in_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(soap, NULL, NULL, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry:
		return soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, NULL, NULL, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		return soap_in_PointerToPointerToselect_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__link_USCORElist2:
		return soap_in_PointerToPointerTons1__link_USCORElist2(soap, NULL, NULL, "ns1:link_list2");
	case SOAP_TYPE_PointerTons1__link_USCORElist2:
		return soap_in_PointerTons1__link_USCORElist2(soap, NULL, NULL, "ns1:link_list2");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		return soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		return soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREvalue2:
		return soap_in_PointerToPointerTons1__link_USCOREvalue2(soap, NULL, NULL, "ns1:link_value2");
	case SOAP_TYPE_PointerTons1__link_USCOREvalue2:
		return soap_in_PointerTons1__link_USCOREvalue2(soap, NULL, NULL, "ns1:link_value2");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_in_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		return soap_in_PointerToPointerTons1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		return soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		return soap_in_PointerToPointerToname_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		return soap_in_PointerToPointerTons1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		return soap_in_PointerTons1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		return soap_in_PointerToPointerTons1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		return soap_in_PointerTons1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerToPointerTons1__field:
		return soap_in_PointerToPointerTons1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerTons1__field:
		return soap_in_PointerTons1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		return soap_in_PointerTons1__error_USCOREvalue(soap, NULL, NULL, "ns1:error_value");
	case SOAP_TYPE_PointerTomodified_USCORErelationship_USCOREentry_USCORElist:
		return soap_in_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, NULL, NULL, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerTosearch_USCORElink_USCOREarray_USCORElist:
		return soap_in_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		return soap_in_PointerTolink_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCORElist:
		return soap_in_PointerTolink_USCORElist(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerToacl_USCORElist:
		return soap_in_PointerToacl_USCORElist(soap, NULL, NULL, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerTomodule_USCORElist_USCOREarray:
		return soap_in_PointerTomodule_USCORElist_USCOREarray(soap, NULL, NULL, "ns1:module_list_entry");
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		return soap_in_PointerTons1__document_USCORErevision(soap, NULL, NULL, "ns1:document_revision");
	case SOAP_TYPE_PointerTosearch_USCORElink_USCORElist:
		return soap_in_PointerTosearch_USCORElink_USCORElist(soap, NULL, NULL, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerTolink_USCORElists:
		return soap_in_PointerTolink_USCORElists(soap, NULL, NULL, "ns1:link_list2");
	case SOAP_TYPE_PointerToentry_USCORElist:
		return soap_in_PointerToentry_USCORElist(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		return soap_in_PointerTolink_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:link_value2");
	case SOAP_TYPE_PointerToselect_USCOREfields:
		return soap_in_PointerToselect_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		return soap_in_PointerToname_USCOREvalue_USCORElists(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		return soap_in_PointerTolink_USCOREfield_USCORElist(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerTofield_USCORElist:
		return soap_in_PointerTofield_USCORElist(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		return soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		return soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_note_attachment");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_modified_relationships"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships;
			return soap_in_ns1__get_USCOREmodified_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_modified_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse;
			return soap_in_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_upcoming_activities"))
		{	*type = SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities;
			return soap_in_ns1__get_USCOREupcoming_USCOREactivities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_upcoming_activitiesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse;
			return soap_in_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_last_viewed"))
		{	*type = SOAP_TYPE_ns1__get_USCORElast_USCOREviewed;
			return soap_in_ns1__get_USCORElast_USCOREviewed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_last_viewedResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse;
			return soap_in_ns1__get_USCORElast_USCOREviewedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fields_md5"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5;
			return soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fields_md5Response"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response;
			return soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_count"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcount;
			return soap_in_ns1__get_USCOREentries_USCOREcount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_countResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse;
			return soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_campaign_merge"))
		{	*type = SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge;
			return soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_campaign_mergeResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse;
			return soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_team_id"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid;
			return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_team_idResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse;
			return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_available_modules"))
		{	*type = SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules;
			return soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_available_modulesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse;
			return soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search_by_module"))
		{	*type = SOAP_TYPE_ns1__search_USCOREby_USCOREmodule;
			return soap_in_ns1__search_USCOREby_USCOREmodule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search_by_moduleResponse"))
		{	*type = SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse;
			return soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_document_revision"))
		{	*type = SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision;
			return soap_in_ns1__get_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_document_revisionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse;
			return soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_document_revision"))
		{	*type = SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision;
			return soap_in_ns1__set_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_document_revisionResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse;
			return soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_note_attachment"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment;
			return soap_in_ns1__get_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_note_attachmentResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse;
			return soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_note_attachment"))
		{	*type = SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment;
			return soap_in_ns1__set_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_note_attachmentResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse;
			return soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:seamless_login"))
		{	*type = SOAP_TYPE_ns1__seamless_USCORElogin;
			return soap_in_ns1__seamless_USCORElogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:seamless_loginResponse"))
		{	*type = SOAP_TYPE_ns1__seamless_USCOREloginResponse;
			return soap_in_ns1__seamless_USCOREloginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fields"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields;
			return soap_in_ns1__get_USCOREmodule_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fieldsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse;
			return soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_id"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREid;
			return soap_in_ns1__get_USCOREuser_USCOREid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_idResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse;
			return soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_info"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo;
			return soap_in_ns1__get_USCOREserver_USCOREinfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_infoResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse;
			return soap_in_ns1__get_USCOREserver_USCOREinfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries;
			return soap_in_ns1__set_USCOREentries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entriesResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentriesResponse;
			return soap_in_ns1__set_USCOREentriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entry"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentry;
			return soap_in_ns1__set_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entryResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentryResponse;
			return soap_in_ns1__set_USCOREentryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_relationships"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelationships;
			return soap_in_ns1__get_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelationshipsResponse;
			return soap_in_ns1__get_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationships"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationships;
			return soap_in_ns1__set_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationshipsResponse;
			return soap_in_ns1__set_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationship"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationship;
			return soap_in_ns1__set_USCORErelationship(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationshipResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationshipResponse;
			return soap_in_ns1__set_USCORErelationshipResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist;
			return soap_in_ns1__get_USCOREentry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_listResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse;
			return soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries;
			return soap_in_ns1__get_USCOREentries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entriesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentriesResponse;
			return soap_in_ns1__get_USCOREentriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry;
			return soap_in_ns1__get_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entryResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentryResponse;
			return soap_in_ns1__get_USCOREentryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE_ns1__login;
			return soap_in_ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE_ns1__loginResponse;
			return soap_in_ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:entry_list2"))
		{	*type = SOAP_TYPE_report_USCOREentry_USCORElist;
			return soap_in_report_USCOREentry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:field_list2"))
		{	*type = SOAP_TYPE_report_USCOREfield_USCORElist;
			return soap_in_report_USCOREfield_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:last_viewed_entry"))
		{	*type = SOAP_TYPE_last_USCOREviewed_USCORElist;
			return soap_in_last_USCOREviewed_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:upcoming_activity_entry"))
		{	*type = SOAP_TYPE_upcoming_USCOREactivities_USCORElist;
			return soap_in_upcoming_USCOREactivities_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_module_USCOREnames;
			return soap_in_module_USCOREnames(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_md5_USCOREresults;
			return soap_in_md5_USCOREresults(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids;
			return soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_name_to_fields_array"))
		{	*type = SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray;
			return soap_in_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:int"))
		{	*type = SOAP_TYPE_deleted_USCOREarray;
			return soap_in_deleted_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:modified_relationship_entry"))
		{	*type = SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist;
			return soap_in_modified_USCORErelationship_USCOREentry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modified_relationship_result"))
		{	*type = SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult;
			return soap_in_ns1__modified_USCORErelationship_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modified_relationship_entry"))
		{	*type = SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry;
			return soap_in_ns1__modified_USCORErelationship_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:error_value"))
		{	*type = SOAP_TYPE_ns1__error_USCOREvalue;
			return soap_in_ns1__error_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist;
			return soap_in_search_USCORElink_USCOREarray_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search_link_name_value"))
		{	*type = SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue;
			return soap_in_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entry_list2"))
		{	*type = SOAP_TYPE_ns1__entry_USCORElist2;
			return soap_in_ns1__entry_USCORElist2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:field_list2"))
		{	*type = SOAP_TYPE_ns1__field_USCORElist2;
			return soap_in_ns1__field_USCORElist2(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_link_USCOREvalue;
			return soap_in_link_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_value2"))
		{	*type = SOAP_TYPE_ns1__link_USCOREvalue2;
			return soap_in_ns1__link_USCOREvalue2(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_name_value"))
		{	*type = SOAP_TYPE_link_USCORElist;
			return soap_in_link_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_list2"))
		{	*type = SOAP_TYPE_ns1__link_USCORElist2;
			return soap_in_ns1__link_USCORElist2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:acl_list_entry"))
		{	*type = SOAP_TYPE_ns1__acl_USCORElist_USCOREentry;
			return soap_in_ns1__acl_USCORElist_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:acl_list_entry"))
		{	*type = SOAP_TYPE_acl_USCORElist;
			return soap_in_acl_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:module_list_entry"))
		{	*type = SOAP_TYPE_ns1__module_USCORElist_USCOREentry;
			return soap_in_ns1__module_USCORElist_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:last_viewed_entry"))
		{	*type = SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry;
			return soap_in_ns1__last_USCOREviewed_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upcoming_activity_entry"))
		{	*type = SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry;
			return soap_in_ns1__upcoming_USCOREactivity_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_count_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult;
			return soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:module_list_entry"))
		{	*type = SOAP_TYPE_module_USCORElist_USCOREarray;
			return soap_in_module_USCORElist_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:module_list"))
		{	*type = SOAP_TYPE_ns1__module_USCORElist;
			return soap_in_ns1__module_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_return_document_revision"))
		{	*type = SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision;
			return soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:document_revision"))
		{	*type = SOAP_TYPE_ns1__document_USCORErevision;
			return soap_in_ns1__document_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_relationship_list_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_entries_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_entry_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_info_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult;
			return soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list_result_version2"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2;
			return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:search_link_name_value"))
		{	*type = SOAP_TYPE_search_USCORElink_USCORElist;
			return soap_in_search_USCORElink_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:return_search_result"))
		{	*type = SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult;
			return soap_in_ns1__return_USCOREsearch_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_list2"))
		{	*type = SOAP_TYPE_link_USCORElists;
			return soap_in_link_USCORElists(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:entry_value"))
		{	*type = SOAP_TYPE_entry_USCORElist;
			return soap_in_entry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_result_version2"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2;
			return soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_value2"))
		{	*type = SOAP_TYPE_link_USCOREarray_USCORElist;
			return soap_in_link_USCOREarray_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_name_value"))
		{	*type = SOAP_TYPE_ns1__link_USCOREname_USCOREvalue;
			return soap_in_ns1__link_USCOREname_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_select_USCOREfields;
			return soap_in_select_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_name_to_fields_array"))
		{	*type = SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray;
			return soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_name_USCOREvalue_USCORElists;
			return soap_in_name_USCOREvalue_USCORElists(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries_detail_result"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult;
			return soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entry_value"))
		{	*type = SOAP_TYPE_ns1__entry_USCOREvalue;
			return soap_in_ns1__entry_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_field"))
		{	*type = SOAP_TYPE_link_USCOREfield_USCORElist;
			return soap_in_link_USCOREfield_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:field"))
		{	*type = SOAP_TYPE_field_USCORElist;
			return soap_in_field_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_module_fields"))
		{	*type = SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields;
			return soap_in_ns1__new_USCOREmodule_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:name_value"))
		{	*type = SOAP_TYPE_ns1__name_USCOREvalue;
			return soap_in_ns1__name_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_field"))
		{	*type = SOAP_TYPE_ns1__link_USCOREfield;
			return soap_in_ns1__link_USCOREfield(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_name_USCOREvalue_USCORElist;
			return soap_in_name_USCOREvalue_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:field"))
		{	*type = SOAP_TYPE_ns1__field;
			return soap_in_ns1__field(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user_auth"))
		{	*type = SOAP_TYPE_ns1__user_USCOREauth;
			return soap_in_ns1__user_USCOREauth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_return_note_attachment"))
		{	*type = SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment;
			return soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_note_attachment"))
		{	*type = SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment;
			return soap_in_ns1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships:
		return soap_out_ns1__get_USCOREmodified_USCORErelationships(soap, tag, id, (const struct ns1__get_USCOREmodified_USCORErelationships *)ptr, "ns1:get_modified_relationships");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse:
		return soap_out_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__get_USCOREmodified_USCORErelationshipsResponse *)ptr, "ns1:get_modified_relationshipsResponse");
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities:
		return soap_out_ns1__get_USCOREupcoming_USCOREactivities(soap, tag, id, (const struct ns1__get_USCOREupcoming_USCOREactivities *)ptr, "ns1:get_upcoming_activities");
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse:
		return soap_out_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, id, (const struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *)ptr, "ns1:get_upcoming_activitiesResponse");
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewed:
		return soap_out_ns1__get_USCORElast_USCOREviewed(soap, tag, id, (const struct ns1__get_USCORElast_USCOREviewed *)ptr, "ns1:get_last_viewed");
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse:
		return soap_out_ns1__get_USCORElast_USCOREviewedResponse(soap, tag, id, (const struct ns1__get_USCORElast_USCOREviewedResponse *)ptr, "ns1:get_last_viewedResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5:
		return soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *)ptr, "ns1:get_module_fields_md5");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		return soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *)ptr, "ns1:get_module_fields_md5Response");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		return soap_out_ns1__get_USCOREentries_USCOREcount(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcount *)ptr, "ns1:get_entries_count");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		return soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcountResponse *)ptr, "ns1:get_entries_countResponse");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		return soap_out_ns1__set_USCOREcampaign_USCOREmerge(soap, tag, id, (const struct ns1__set_USCOREcampaign_USCOREmerge *)ptr, "ns1:set_campaign_merge");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, (const struct ns1__set_USCOREcampaign_USCOREmergeResponse *)ptr, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		return soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREteam_USCOREid *)ptr, "ns1:get_user_team_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		return soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)ptr, "ns1:get_user_team_idResponse");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		return soap_out_ns1__get_USCOREavailable_USCOREmodules(soap, tag, id, (const struct ns1__get_USCOREavailable_USCOREmodules *)ptr, "ns1:get_available_modules");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, (const struct ns1__get_USCOREavailable_USCOREmodulesResponse *)ptr, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		return soap_out_ns1__search_USCOREby_USCOREmodule(soap, tag, id, (const struct ns1__search_USCOREby_USCOREmodule *)ptr, "ns1:search_by_module");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		return soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, (const struct ns1__search_USCOREby_USCOREmoduleResponse *)ptr, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		return soap_out_ns1__get_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__get_USCOREdocument_USCORErevision *)ptr, "ns1:get_document_revision");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		return soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, (const struct ns1__get_USCOREdocument_USCORErevisionResponse *)ptr, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		return soap_out_ns1__set_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__set_USCOREdocument_USCORErevision *)ptr, "ns1:set_document_revision");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		return soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, (const struct ns1__set_USCOREdocument_USCORErevisionResponse *)ptr, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		return soap_out_ns1__get_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__get_USCOREnote_USCOREattachment *)ptr, "ns1:get_note_attachment");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		return soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, (const struct ns1__get_USCOREnote_USCOREattachmentResponse *)ptr, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		return soap_out_ns1__set_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__set_USCOREnote_USCOREattachment *)ptr, "ns1:set_note_attachment");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		return soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, (const struct ns1__set_USCOREnote_USCOREattachmentResponse *)ptr, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		return soap_out_ns1__seamless_USCORElogin(soap, tag, id, (const struct ns1__seamless_USCORElogin *)ptr, "ns1:seamless_login");
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		return soap_out_ns1__seamless_USCOREloginResponse(soap, tag, id, (const struct ns1__seamless_USCOREloginResponse *)ptr, "ns1:seamless_loginResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		return soap_out_ns1__get_USCOREmodule_USCOREfields(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfields *)ptr, "ns1:get_module_fields");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfieldsResponse *)ptr, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		return soap_out_ns1__get_USCOREuser_USCOREid(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREid *)ptr, "ns1:get_user_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		return soap_out_ns1__get_USCOREuser_USCOREidResponse(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREidResponse *)ptr, "ns1:get_user_idResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo:
		return soap_out_ns1__get_USCOREserver_USCOREinfo(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREinfo *)ptr, "ns1:get_server_info");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse:
		return soap_out_ns1__get_USCOREserver_USCOREinfoResponse(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREinfoResponse *)ptr, "ns1:get_server_infoResponse");
	case SOAP_TYPE_ns1__set_USCOREentries:
		return soap_out_ns1__set_USCOREentries(soap, tag, id, (const struct ns1__set_USCOREentries *)ptr, "ns1:set_entries");
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		return soap_out_ns1__set_USCOREentriesResponse(soap, tag, id, (const struct ns1__set_USCOREentriesResponse *)ptr, "ns1:set_entriesResponse");
	case SOAP_TYPE_ns1__set_USCOREentry:
		return soap_out_ns1__set_USCOREentry(soap, tag, id, (const struct ns1__set_USCOREentry *)ptr, "ns1:set_entry");
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		return soap_out_ns1__set_USCOREentryResponse(soap, tag, id, (const struct ns1__set_USCOREentryResponse *)ptr, "ns1:set_entryResponse");
	case SOAP_TYPE_ns1__get_USCORErelationships:
		return soap_out_ns1__get_USCORErelationships(soap, tag, id, (const struct ns1__get_USCORErelationships *)ptr, "ns1:get_relationships");
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		return soap_out_ns1__get_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__get_USCORErelationshipsResponse *)ptr, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationships:
		return soap_out_ns1__set_USCORErelationships(soap, tag, id, (const struct ns1__set_USCORErelationships *)ptr, "ns1:set_relationships");
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		return soap_out_ns1__set_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__set_USCORErelationshipsResponse *)ptr, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationship:
		return soap_out_ns1__set_USCORErelationship(soap, tag, id, (const struct ns1__set_USCORErelationship *)ptr, "ns1:set_relationship");
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		return soap_out_ns1__set_USCORErelationshipResponse(soap, tag, id, (const struct ns1__set_USCORErelationshipResponse *)ptr, "ns1:set_relationshipResponse");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		return soap_out_ns1__get_USCOREentry_USCORElist(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist *)ptr, "ns1:get_entry_list");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		return soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElistResponse *)ptr, "ns1:get_entry_listResponse");
	case SOAP_TYPE_ns1__get_USCOREentries:
		return soap_out_ns1__get_USCOREentries(soap, tag, id, (const struct ns1__get_USCOREentries *)ptr, "ns1:get_entries");
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		return soap_out_ns1__get_USCOREentriesResponse(soap, tag, id, (const struct ns1__get_USCOREentriesResponse *)ptr, "ns1:get_entriesResponse");
	case SOAP_TYPE_ns1__get_USCOREentry:
		return soap_out_ns1__get_USCOREentry(soap, tag, id, (const struct ns1__get_USCOREentry *)ptr, "ns1:get_entry");
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		return soap_out_ns1__get_USCOREentryResponse(soap, tag, id, (const struct ns1__get_USCOREentryResponse *)ptr, "ns1:get_entryResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_out_ns1__logout(soap, tag, id, (const struct ns1__logout *)ptr, "ns1:logout");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_out_ns1__logoutResponse(soap, tag, id, (const struct ns1__logoutResponse *)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__login:
		return soap_out_ns1__login(soap, tag, id, (const struct ns1__login *)ptr, "ns1:login");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_out_ns1__loginResponse(soap, tag, id, (const struct ns1__loginResponse *)ptr, "ns1:loginResponse");
	case SOAP_TYPE_report_USCOREentry_USCORElist:
		return soap_out_report_USCOREentry_USCORElist(soap, tag, id, (const struct report_USCOREentry_USCORElist *)ptr, "ns1:entry_list2");
	case SOAP_TYPE_report_USCOREfield_USCORElist:
		return soap_out_report_USCOREfield_USCORElist(soap, tag, id, (const struct report_USCOREfield_USCORElist *)ptr, "ns1:field_list2");
	case SOAP_TYPE_last_USCOREviewed_USCORElist:
		return soap_out_last_USCOREviewed_USCORElist(soap, tag, id, (const struct last_USCOREviewed_USCORElist *)ptr, "ns1:last_viewed_entry");
	case SOAP_TYPE_upcoming_USCOREactivities_USCORElist:
		return soap_out_upcoming_USCOREactivities_USCORElist(soap, tag, id, (const struct upcoming_USCOREactivities_USCORElist *)ptr, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_module_USCOREnames:
		return soap_out_module_USCOREnames(soap, tag, id, (const struct module_USCOREnames *)ptr, "xsd:string");
	case SOAP_TYPE_md5_USCOREresults:
		return soap_out_md5_USCOREresults(soap, tag, id, (const struct md5_USCOREresults *)ptr, "xsd:string");
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		return soap_out_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, id, (const struct new_USCOREset_USCORErelationhip_USCOREids *)ptr, "xsd:string");
	case SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		return soap_out_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (const struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_deleted_USCOREarray:
		return soap_out_deleted_USCOREarray(soap, tag, id, (const struct deleted_USCOREarray *)ptr, "xsd:int");
	case SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist:
		return soap_out_modified_USCORErelationship_USCOREentry_USCORElist(soap, tag, id, (const struct modified_USCORErelationship_USCOREentry_USCORElist *)ptr, "ns1:modified_relationship_entry");
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult:
		return soap_out_ns1__modified_USCORErelationship_USCOREresult(soap, tag, id, (const struct ns1__modified_USCORErelationship_USCOREresult *)ptr, "ns1:modified_relationship_result");
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry:
		return soap_out_ns1__modified_USCORErelationship_USCOREentry(soap, tag, id, (const struct ns1__modified_USCORErelationship_USCOREentry *)ptr, "ns1:modified_relationship_entry");
	case SOAP_TYPE_ns1__error_USCOREvalue:
		return soap_out_ns1__error_USCOREvalue(soap, tag, id, (const struct ns1__error_USCOREvalue *)ptr, "ns1:error_value");
	case SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist:
		return soap_out_search_USCORElink_USCOREarray_USCORElist(soap, tag, id, (const struct search_USCORElink_USCOREarray_USCORElist *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_out_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, id, (const struct ns1__search_USCORElink_USCOREname_USCOREvalue *)ptr, "ns1:search_link_name_value");
	case SOAP_TYPE_ns1__entry_USCORElist2:
		return soap_out_ns1__entry_USCORElist2(soap, tag, id, (const struct ns1__entry_USCORElist2 *)ptr, "ns1:entry_list2");
	case SOAP_TYPE_ns1__field_USCORElist2:
		return soap_out_ns1__field_USCORElist2(soap, tag, id, (const struct ns1__field_USCORElist2 *)ptr, "ns1:field_list2");
	case SOAP_TYPE_link_USCOREvalue:
		return soap_out_link_USCOREvalue(soap, tag, id, (const struct link_USCOREvalue *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREvalue2:
		return soap_out_ns1__link_USCOREvalue2(soap, tag, id, (const struct ns1__link_USCOREvalue2 *)ptr, "ns1:link_value2");
	case SOAP_TYPE_link_USCORElist:
		return soap_out_link_USCORElist(soap, tag, id, (const struct link_USCORElist *)ptr, "ns1:link_name_value");
	case SOAP_TYPE_ns1__link_USCORElist2:
		return soap_out_ns1__link_USCORElist2(soap, tag, id, (const struct ns1__link_USCORElist2 *)ptr, "ns1:link_list2");
	case SOAP_TYPE_ns1__acl_USCORElist_USCOREentry:
		return soap_out_ns1__acl_USCORElist_USCOREentry(soap, tag, id, (const struct ns1__acl_USCORElist_USCOREentry *)ptr, "ns1:acl_list_entry");
	case SOAP_TYPE_acl_USCORElist:
		return soap_out_acl_USCORElist(soap, tag, id, (const struct acl_USCORElist *)ptr, "ns1:acl_list_entry");
	case SOAP_TYPE_ns1__module_USCORElist_USCOREentry:
		return soap_out_ns1__module_USCORElist_USCOREentry(soap, tag, id, (const struct ns1__module_USCORElist_USCOREentry *)ptr, "ns1:module_list_entry");
	case SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry:
		return soap_out_ns1__last_USCOREviewed_USCOREentry(soap, tag, id, (const struct ns1__last_USCOREviewed_USCOREentry *)ptr, "ns1:last_viewed_entry");
	case SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry:
		return soap_out_ns1__upcoming_USCOREactivity_USCOREentry(soap, tag, id, (const struct ns1__upcoming_USCOREactivity_USCOREentry *)ptr, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)ptr, "ns1:get_entries_count_result");
	case SOAP_TYPE_module_USCORElist_USCOREarray:
		return soap_out_module_USCORElist_USCOREarray(soap, tag, id, (const struct module_USCORElist_USCOREarray *)ptr, "ns1:module_list_entry");
	case SOAP_TYPE_ns1__module_USCORElist:
		return soap_out_ns1__module_USCORElist(soap, tag, id, (const struct ns1__module_USCORElist *)ptr, "ns1:module_list");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)ptr, "ns1:new_return_document_revision");
	case SOAP_TYPE_ns1__document_USCORErevision:
		return soap_out_ns1__document_USCORErevision(soap, tag, id, (const struct ns1__document_USCORErevision *)ptr, "ns1:document_revision");
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)ptr, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCOREentries_USCOREresult *)ptr, "ns1:new_set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCOREentry_USCOREresult *)ptr, "ns1:new_set_entry_result");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)ptr, "ns1:get_server_info_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)ptr, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_search_USCORElink_USCORElist:
		return soap_out_search_USCORElink_USCORElist(soap, tag, id, (const struct search_USCORElink_USCORElist *)ptr, "ns1:search_link_name_value");
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		return soap_out_ns1__return_USCOREsearch_USCOREresult(soap, tag, id, (const struct ns1__return_USCOREsearch_USCOREresult *)ptr, "ns1:return_search_result");
	case SOAP_TYPE_link_USCORElists:
		return soap_out_link_USCORElists(soap, tag, id, (const struct link_USCORElists *)ptr, "ns1:link_list2");
	case SOAP_TYPE_entry_USCORElist:
		return soap_out_entry_USCORElist(soap, tag, id, (const struct entry_USCORElist *)ptr, "ns1:entry_value");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, id, (const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)ptr, "ns1:get_entry_result_version2");
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		return soap_out_link_USCOREarray_USCORElist(soap, tag, id, (const struct link_USCOREarray_USCORElist *)ptr, "ns1:link_value2");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		return soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag, id, (const struct ns1__link_USCOREname_USCOREvalue *)ptr, "ns1:link_name_value");
	case SOAP_TYPE_select_USCOREfields:
		return soap_out_select_USCOREfields(soap, tag, id, (const struct select_USCOREfields *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		return soap_out_name_USCOREvalue_USCORElists(soap, tag, id, (const struct name_USCOREvalue_USCORElists *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, (const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)ptr, "ns1:set_entries_detail_result");
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		return soap_out_ns1__entry_USCOREvalue(soap, tag, id, (const struct ns1__entry_USCOREvalue *)ptr, "ns1:entry_value");
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		return soap_out_link_USCOREfield_USCORElist(soap, tag, id, (const struct link_USCOREfield_USCORElist *)ptr, "ns1:link_field");
	case SOAP_TYPE_field_USCORElist:
		return soap_out_field_USCORElist(soap, tag, id, (const struct field_USCORElist *)ptr, "ns1:field");
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		return soap_out_ns1__new_USCOREmodule_USCOREfields(soap, tag, id, (const struct ns1__new_USCOREmodule_USCOREfields *)ptr, "ns1:new_module_fields");
	case SOAP_TYPE_ns1__name_USCOREvalue:
		return soap_out_ns1__name_USCOREvalue(soap, tag, id, (const struct ns1__name_USCOREvalue *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREfield:
		return soap_out_ns1__link_USCOREfield(soap, tag, id, (const struct ns1__link_USCOREfield *)ptr, "ns1:link_field");
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		return soap_out_name_USCOREvalue_USCORElist(soap, tag, id, (const struct name_USCOREvalue_USCORElist *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__field:
		return soap_out_ns1__field(soap, tag, id, (const struct ns1__field *)ptr, "ns1:field");
	case SOAP_TYPE_ns1__user_USCOREauth:
		return soap_out_ns1__user_USCOREauth(soap, tag, id, (const struct ns1__user_USCOREauth *)ptr, "ns1:user_auth");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)ptr, "ns1:new_return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		return soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__new_USCOREnote_USCOREattachment *)ptr, "ns1:new_note_attachment");
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse:
		return soap_out_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, (struct ns1__get_USCOREmodified_USCORErelationshipsResponse *const*)ptr, "ns1:get_modified_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREresult:
		return soap_out_PointerTons1__modified_USCORErelationship_USCOREresult(soap, tag, id, (struct ns1__modified_USCORErelationship_USCOREresult *const*)ptr, "ns1:modified_relationship_result");
	case SOAP_TYPE_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse:
		return soap_out_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, id, (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *const*)ptr, "ns1:get_upcoming_activitiesResponse");
	case SOAP_TYPE_PointerToupcoming_USCOREactivities_USCORElist:
		return soap_out_PointerToupcoming_USCOREactivities_USCORElist(soap, tag, id, (struct upcoming_USCOREactivities_USCORElist *const*)ptr, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerTons1__get_USCORElast_USCOREviewedResponse:
		return soap_out_PointerTons1__get_USCORElast_USCOREviewedResponse(soap, tag, id, (struct ns1__get_USCORElast_USCOREviewedResponse *const*)ptr, "ns1:get_last_viewedResponse");
	case SOAP_TYPE_PointerTomodule_USCOREnames:
		return soap_out_PointerTomodule_USCOREnames(soap, tag, id, (struct module_USCOREnames *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTolast_USCOREviewed_USCORElist:
		return soap_out_PointerTolast_USCOREviewed_USCORElist(soap, tag, id, (struct last_USCOREviewed_USCORElist *const*)ptr, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		return soap_out_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, id, (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *const*)ptr, "ns1:get_module_fields_md5Response");
	case SOAP_TYPE_PointerTomd5_USCOREresults:
		return soap_out_PointerTomd5_USCOREresults(soap, tag, id, (struct md5_USCOREresults *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		return soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag, id, (struct ns1__get_USCOREentries_USCOREcountResponse *const*)ptr, "ns1:get_entries_countResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*)ptr, "ns1:get_entries_count_result");
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, (struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*)ptr, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, (struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*)ptr, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		return soap_out_PointerTons1__module_USCORElist(soap, tag, id, (struct ns1__module_USCORElist *const*)ptr, "ns1:module_list");
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		return soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, (struct ns1__search_USCOREby_USCOREmoduleResponse *const*)ptr, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREsearch_USCOREresult:
		return soap_out_PointerTons1__return_USCOREsearch_USCOREresult(soap, tag, id, (struct ns1__return_USCOREsearch_USCOREresult *const*)ptr, "ns1:return_search_result");
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		return soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, (struct ns1__get_USCOREdocument_USCORErevisionResponse *const*)ptr, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_out_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, id, (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *const*)ptr, "ns1:new_return_document_revision");
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		return soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, (struct ns1__set_USCOREdocument_USCORErevisionResponse *const*)ptr, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		return soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, (struct ns1__get_USCOREnote_USCOREattachmentResponse *const*)ptr, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_out_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, id, (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *const*)ptr, "ns1:new_return_note_attachment");
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		return soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, (struct ns1__set_USCOREnote_USCOREattachmentResponse *const*)ptr, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, (struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*)ptr, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREmodule_USCOREfields:
		return soap_out_PointerTons1__new_USCOREmodule_USCOREfields(soap, tag, id, (struct ns1__new_USCOREmodule_USCOREfields *const*)ptr, "ns1:new_module_fields");
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfoResponse:
		return soap_out_PointerTons1__get_USCOREserver_USCOREinfoResponse(soap, tag, id, (struct ns1__get_USCOREserver_USCOREinfoResponse *const*)ptr, "ns1:get_server_infoResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_out_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, id, (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *const*)ptr, "ns1:get_server_info_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		return soap_out_PointerTons1__set_USCOREentriesResponse(soap, tag, id, (struct ns1__set_USCOREentriesResponse *const*)ptr, "ns1:set_entriesResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_out_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, id, (struct ns1__new_USCOREset_USCOREentries_USCOREresult *const*)ptr, "ns1:new_set_entries_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		return soap_out_PointerTons1__set_USCOREentryResponse(soap, tag, id, (struct ns1__set_USCOREentryResponse *const*)ptr, "ns1:set_entryResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, id, (struct ns1__new_USCOREset_USCOREentry_USCOREresult *const*)ptr, "ns1:new_set_entry_result");
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		return soap_out_PointerTons1__get_USCORErelationshipsResponse(soap, tag, id, (struct ns1__get_USCORErelationshipsResponse *const*)ptr, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		return soap_out_PointerTons1__set_USCORErelationshipsResponse(soap, tag, id, (struct ns1__set_USCORErelationshipsResponse *const*)ptr, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_PointerTodeleted_USCOREarray:
		return soap_out_PointerTodeleted_USCOREarray(soap, tag, id, (struct deleted_USCOREarray *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTonew_USCOREset_USCORErelationhip_USCOREids:
		return soap_out_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, tag, id, (struct new_USCOREset_USCORErelationhip_USCOREids *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		return soap_out_PointerTons1__set_USCORErelationshipResponse(soap, tag, id, (struct ns1__set_USCORErelationshipResponse *const*)ptr, "ns1:set_relationshipResponse");
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_out_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *const*)ptr, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		return soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag, id, (struct ns1__get_USCOREentry_USCORElistResponse *const*)ptr, "ns1:get_entry_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, id, (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *const*)ptr, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		return soap_out_PointerTons1__get_USCOREentriesResponse(soap, tag, id, (struct ns1__get_USCOREentriesResponse *const*)ptr, "ns1:get_entriesResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		return soap_out_PointerTons1__get_USCOREentryResponse(soap, tag, id, (struct ns1__get_USCOREentryResponse *const*)ptr, "ns1:get_entryResponse");
	case SOAP_TYPE_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		return soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *const*)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, id, (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *const*)ptr, "ns1:get_entry_result_version2");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_out_PointerTons1__logoutResponse(soap, tag, id, (struct ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_out_PointerTons1__loginResponse(soap, tag, id, (struct ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		return soap_out_PointerTons1__user_USCOREauth(soap, tag, id, (struct ns1__user_USCOREauth *const*)ptr, "ns1:user_auth");
	case SOAP_TYPE_PointerToPointerTons1__modified_USCORErelationship_USCOREentry:
		return soap_out_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, id, (struct ns1__modified_USCORErelationship_USCOREentry **const*)ptr, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry:
		return soap_out_PointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, id, (struct ns1__modified_USCORErelationship_USCOREentry *const*)ptr, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		return soap_out_PointerToPointerTolink_USCOREvalue(soap, tag, id, (struct link_USCOREvalue **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_out_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__search_USCORElink_USCOREname_USCOREvalue **const*)ptr, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		return soap_out_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__search_USCORElink_USCOREname_USCOREvalue *const*)ptr, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCORElist2:
		return soap_out_PointerToPointerTons1__entry_USCORElist2(soap, tag, id, (struct ns1__entry_USCORElist2 **const*)ptr, "ns1:entry_list2");
	case SOAP_TYPE_PointerTons1__entry_USCORElist2:
		return soap_out_PointerTons1__entry_USCORElist2(soap, tag, id, (struct ns1__entry_USCORElist2 *const*)ptr, "ns1:entry_list2");
	case SOAP_TYPE_PointerToPointerTons1__field_USCORElist2:
		return soap_out_PointerToPointerTons1__field_USCORElist2(soap, tag, id, (struct ns1__field_USCORElist2 **const*)ptr, "ns1:field_list2");
	case SOAP_TYPE_PointerTons1__field_USCORElist2:
		return soap_out_PointerTons1__field_USCORElist2(soap, tag, id, (struct ns1__field_USCORElist2 *const*)ptr, "ns1:field_list2");
	case SOAP_TYPE_PointerToPointerTons1__acl_USCORElist_USCOREentry:
		return soap_out_PointerToPointerTons1__acl_USCORElist_USCOREentry(soap, tag, id, (struct ns1__acl_USCORElist_USCOREentry **const*)ptr, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry:
		return soap_out_PointerTons1__acl_USCORElist_USCOREentry(soap, tag, id, (struct ns1__acl_USCORElist_USCOREentry *const*)ptr, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerToPointerTons1__module_USCORElist_USCOREentry:
		return soap_out_PointerToPointerTons1__module_USCORElist_USCOREentry(soap, tag, id, (struct ns1__module_USCORElist_USCOREentry **const*)ptr, "ns1:module_list_entry");
	case SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry:
		return soap_out_PointerTons1__module_USCORElist_USCOREentry(soap, tag, id, (struct ns1__module_USCORElist_USCOREentry *const*)ptr, "ns1:module_list_entry");
	case SOAP_TYPE_PointerToPointerTons1__last_USCOREviewed_USCOREentry:
		return soap_out_PointerToPointerTons1__last_USCOREviewed_USCOREentry(soap, tag, id, (struct ns1__last_USCOREviewed_USCOREentry **const*)ptr, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry:
		return soap_out_PointerTons1__last_USCOREviewed_USCOREentry(soap, tag, id, (struct ns1__last_USCOREviewed_USCOREentry *const*)ptr, "ns1:last_viewed_entry");
	case SOAP_TYPE_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry:
		return soap_out_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, id, (struct ns1__upcoming_USCOREactivity_USCOREentry **const*)ptr, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry:
		return soap_out_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, id, (struct ns1__upcoming_USCOREactivity_USCOREentry *const*)ptr, "ns1:upcoming_activity_entry");
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		return soap_out_PointerToPointerToselect_USCOREfields(soap, tag, id, (struct select_USCOREfields **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__link_USCORElist2:
		return soap_out_PointerToPointerTons1__link_USCORElist2(soap, tag, id, (struct ns1__link_USCORElist2 **const*)ptr, "ns1:link_list2");
	case SOAP_TYPE_PointerTons1__link_USCORElist2:
		return soap_out_PointerTons1__link_USCORElist2(soap, tag, id, (struct ns1__link_USCORElist2 *const*)ptr, "ns1:link_list2");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		return soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__link_USCOREname_USCOREvalue **const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		return soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__link_USCOREname_USCOREvalue *const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREvalue2:
		return soap_out_PointerToPointerTons1__link_USCOREvalue2(soap, tag, id, (struct ns1__link_USCOREvalue2 **const*)ptr, "ns1:link_value2");
	case SOAP_TYPE_PointerTons1__link_USCOREvalue2:
		return soap_out_PointerTons1__link_USCOREvalue2(soap, tag, id, (struct ns1__link_USCOREvalue2 *const*)ptr, "ns1:link_value2");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_out_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **const*)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_out_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *const*)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		return soap_out_PointerToPointerTons1__entry_USCOREvalue(soap, tag, id, (struct ns1__entry_USCOREvalue **const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		return soap_out_PointerTons1__entry_USCOREvalue(soap, tag, id, (struct ns1__entry_USCOREvalue *const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		return soap_out_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag, id, (struct name_USCOREvalue_USCORElist **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		return soap_out_PointerToPointerTons1__name_USCOREvalue(soap, tag, id, (struct ns1__name_USCOREvalue **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		return soap_out_PointerTons1__name_USCOREvalue(soap, tag, id, (struct ns1__name_USCOREvalue *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		return soap_out_PointerToPointerTons1__link_USCOREfield(soap, tag, id, (struct ns1__link_USCOREfield **const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		return soap_out_PointerTons1__link_USCOREfield(soap, tag, id, (struct ns1__link_USCOREfield *const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerToPointerTons1__field:
		return soap_out_PointerToPointerTons1__field(soap, tag, id, (struct ns1__field **const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerTons1__field:
		return soap_out_PointerTons1__field(soap, tag, id, (struct ns1__field *const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		return soap_out_PointerTons1__error_USCOREvalue(soap, tag, id, (struct ns1__error_USCOREvalue *const*)ptr, "ns1:error_value");
	case SOAP_TYPE_PointerTomodified_USCORErelationship_USCOREentry_USCORElist:
		return soap_out_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, tag, id, (struct modified_USCORErelationship_USCOREentry_USCORElist *const*)ptr, "ns1:modified_relationship_entry");
	case SOAP_TYPE_PointerTosearch_USCORElink_USCOREarray_USCORElist:
		return soap_out_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, tag, id, (struct search_USCORElink_USCOREarray_USCORElist *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		return soap_out_PointerTolink_USCOREvalue(soap, tag, id, (struct link_USCOREvalue *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCORElist:
		return soap_out_PointerTolink_USCORElist(soap, tag, id, (struct link_USCORElist *const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerToacl_USCORElist:
		return soap_out_PointerToacl_USCORElist(soap, tag, id, (struct acl_USCORElist *const*)ptr, "ns1:acl_list_entry");
	case SOAP_TYPE_PointerTomodule_USCORElist_USCOREarray:
		return soap_out_PointerTomodule_USCORElist_USCOREarray(soap, tag, id, (struct module_USCORElist_USCOREarray *const*)ptr, "ns1:module_list_entry");
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		return soap_out_PointerTons1__document_USCORErevision(soap, tag, id, (struct ns1__document_USCORErevision *const*)ptr, "ns1:document_revision");
	case SOAP_TYPE_PointerTosearch_USCORElink_USCORElist:
		return soap_out_PointerTosearch_USCORElink_USCORElist(soap, tag, id, (struct search_USCORElink_USCORElist *const*)ptr, "ns1:search_link_name_value");
	case SOAP_TYPE_PointerTolink_USCORElists:
		return soap_out_PointerTolink_USCORElists(soap, tag, id, (struct link_USCORElists *const*)ptr, "ns1:link_list2");
	case SOAP_TYPE_PointerToentry_USCORElist:
		return soap_out_PointerToentry_USCORElist(soap, tag, id, (struct entry_USCORElist *const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		return soap_out_PointerTolink_USCOREarray_USCORElist(soap, tag, id, (struct link_USCOREarray_USCORElist *const*)ptr, "ns1:link_value2");
	case SOAP_TYPE_PointerToselect_USCOREfields:
		return soap_out_PointerToselect_USCOREfields(soap, tag, id, (struct select_USCOREfields *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		return soap_out_PointerToname_USCOREvalue_USCORElists(soap, tag, id, (struct name_USCOREvalue_USCORElists *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		return soap_out_PointerTolink_USCOREfield_USCORElist(soap, tag, id, (struct link_USCOREfield_USCORElist *const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerTofield_USCORElist:
		return soap_out_PointerTofield_USCORElist(soap, tag, id, (struct field_USCORElist *const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		return soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag, id, (struct name_USCOREvalue_USCORElist *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		return soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag, id, (struct ns1__new_USCOREnote_USCOREattachment *const*)ptr, "ns1:new_note_attachment");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships:
		soap_serialize_ns1__get_USCOREmodified_USCORErelationships(soap, (const struct ns1__get_USCOREmodified_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse:
		soap_serialize_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, (const struct ns1__get_USCOREmodified_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities:
		soap_serialize_ns1__get_USCOREupcoming_USCOREactivities(soap, (const struct ns1__get_USCOREupcoming_USCOREactivities *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse:
		soap_serialize_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, (const struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewed:
		soap_serialize_ns1__get_USCORElast_USCOREviewed(soap, (const struct ns1__get_USCORElast_USCOREviewed *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse:
		soap_serialize_ns1__get_USCORElast_USCOREviewedResponse(soap, (const struct ns1__get_USCORElast_USCOREviewedResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5:
		soap_serialize_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, (const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		soap_serialize_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, (const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		soap_serialize_ns1__get_USCOREentries_USCOREcount(soap, (const struct ns1__get_USCOREentries_USCOREcount *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(soap, (const struct ns1__get_USCOREentries_USCOREcountResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		soap_serialize_ns1__set_USCOREcampaign_USCOREmerge(soap, (const struct ns1__set_USCOREcampaign_USCOREmerge *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, (const struct ns1__set_USCOREcampaign_USCOREmergeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, (const struct ns1__get_USCOREuser_USCOREteam_USCOREid *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, (const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		soap_serialize_ns1__get_USCOREavailable_USCOREmodules(soap, (const struct ns1__get_USCOREavailable_USCOREmodules *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, (const struct ns1__get_USCOREavailable_USCOREmodulesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		soap_serialize_ns1__search_USCOREby_USCOREmodule(soap, (const struct ns1__search_USCOREby_USCOREmodule *)ptr);
		break;
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(soap, (const struct ns1__search_USCOREby_USCOREmoduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		soap_serialize_ns1__get_USCOREdocument_USCORErevision(soap, (const struct ns1__get_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(soap, (const struct ns1__get_USCOREdocument_USCORErevisionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		soap_serialize_ns1__set_USCOREdocument_USCORErevision(soap, (const struct ns1__set_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(soap, (const struct ns1__set_USCOREdocument_USCORErevisionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		soap_serialize_ns1__get_USCOREnote_USCOREattachment(soap, (const struct ns1__get_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(soap, (const struct ns1__get_USCOREnote_USCOREattachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		soap_serialize_ns1__set_USCOREnote_USCOREattachment(soap, (const struct ns1__set_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(soap, (const struct ns1__set_USCOREnote_USCOREattachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		soap_serialize_ns1__seamless_USCORElogin(soap, (const struct ns1__seamless_USCORElogin *)ptr);
		break;
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		soap_serialize_ns1__seamless_USCOREloginResponse(soap, (const struct ns1__seamless_USCOREloginResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		soap_serialize_ns1__get_USCOREmodule_USCOREfields(soap, (const struct ns1__get_USCOREmodule_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, (const struct ns1__get_USCOREmodule_USCOREfieldsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		soap_serialize_ns1__get_USCOREuser_USCOREid(soap, (const struct ns1__get_USCOREuser_USCOREid *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		soap_serialize_ns1__get_USCOREuser_USCOREidResponse(soap, (const struct ns1__get_USCOREuser_USCOREidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo:
		soap_serialize_ns1__get_USCOREserver_USCOREinfo(soap, (const struct ns1__get_USCOREserver_USCOREinfo *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse:
		soap_serialize_ns1__get_USCOREserver_USCOREinfoResponse(soap, (const struct ns1__get_USCOREserver_USCOREinfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries:
		soap_serialize_ns1__set_USCOREentries(soap, (const struct ns1__set_USCOREentries *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		soap_serialize_ns1__set_USCOREentriesResponse(soap, (const struct ns1__set_USCOREentriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentry:
		soap_serialize_ns1__set_USCOREentry(soap, (const struct ns1__set_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		soap_serialize_ns1__set_USCOREentryResponse(soap, (const struct ns1__set_USCOREentryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelationships:
		soap_serialize_ns1__get_USCORErelationships(soap, (const struct ns1__get_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		soap_serialize_ns1__get_USCORErelationshipsResponse(soap, (const struct ns1__get_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationships:
		soap_serialize_ns1__set_USCORErelationships(soap, (const struct ns1__set_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		soap_serialize_ns1__set_USCORErelationshipsResponse(soap, (const struct ns1__set_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationship:
		soap_serialize_ns1__set_USCORErelationship(soap, (const struct ns1__set_USCORErelationship *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		soap_serialize_ns1__set_USCORErelationshipResponse(soap, (const struct ns1__set_USCORErelationshipResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		soap_serialize_ns1__get_USCOREentry_USCORElist(soap, (const struct ns1__get_USCOREentry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		soap_serialize_ns1__get_USCOREentry_USCORElistResponse(soap, (const struct ns1__get_USCOREentry_USCORElistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries:
		soap_serialize_ns1__get_USCOREentries(soap, (const struct ns1__get_USCOREentries *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		soap_serialize_ns1__get_USCOREentriesResponse(soap, (const struct ns1__get_USCOREentriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry:
		soap_serialize_ns1__get_USCOREentry(soap, (const struct ns1__get_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		soap_serialize_ns1__get_USCOREentryResponse(soap, (const struct ns1__get_USCOREentryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__logout:
		soap_serialize_ns1__logout(soap, (const struct ns1__logout *)ptr);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		soap_serialize_ns1__logoutResponse(soap, (const struct ns1__logoutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__login:
		soap_serialize_ns1__login(soap, (const struct ns1__login *)ptr);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		soap_serialize_ns1__loginResponse(soap, (const struct ns1__loginResponse *)ptr);
		break;
	case SOAP_TYPE_report_USCOREentry_USCORElist:
		soap_serialize_report_USCOREentry_USCORElist(soap, (const struct report_USCOREentry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_report_USCOREfield_USCORElist:
		soap_serialize_report_USCOREfield_USCORElist(soap, (const struct report_USCOREfield_USCORElist *)ptr);
		break;
	case SOAP_TYPE_last_USCOREviewed_USCORElist:
		soap_serialize_last_USCOREviewed_USCORElist(soap, (const struct last_USCOREviewed_USCORElist *)ptr);
		break;
	case SOAP_TYPE_upcoming_USCOREactivities_USCORElist:
		soap_serialize_upcoming_USCOREactivities_USCORElist(soap, (const struct upcoming_USCOREactivities_USCORElist *)ptr);
		break;
	case SOAP_TYPE_module_USCOREnames:
		soap_serialize_module_USCOREnames(soap, (const struct module_USCOREnames *)ptr);
		break;
	case SOAP_TYPE_md5_USCOREresults:
		soap_serialize_md5_USCOREresults(soap, (const struct md5_USCOREresults *)ptr);
		break;
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		soap_serialize_new_USCOREset_USCORErelationhip_USCOREids(soap, (const struct new_USCOREset_USCORErelationhip_USCOREids *)ptr);
		break;
	case SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, (const struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_deleted_USCOREarray:
		soap_serialize_deleted_USCOREarray(soap, (const struct deleted_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist:
		soap_serialize_modified_USCORErelationship_USCOREentry_USCORElist(soap, (const struct modified_USCORErelationship_USCOREentry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult:
		soap_serialize_ns1__modified_USCORErelationship_USCOREresult(soap, (const struct ns1__modified_USCORErelationship_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry:
		soap_serialize_ns1__modified_USCORErelationship_USCOREentry(soap, (const struct ns1__modified_USCORErelationship_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__error_USCOREvalue:
		soap_serialize_ns1__error_USCOREvalue(soap, (const struct ns1__error_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist:
		soap_serialize_search_USCORElink_USCOREarray_USCORElist(soap, (const struct search_USCORElink_USCOREarray_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue:
		soap_serialize_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, (const struct ns1__search_USCORElink_USCOREname_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__entry_USCORElist2:
		soap_serialize_ns1__entry_USCORElist2(soap, (const struct ns1__entry_USCORElist2 *)ptr);
		break;
	case SOAP_TYPE_ns1__field_USCORElist2:
		soap_serialize_ns1__field_USCORElist2(soap, (const struct ns1__field_USCORElist2 *)ptr);
		break;
	case SOAP_TYPE_link_USCOREvalue:
		soap_serialize_link_USCOREvalue(soap, (const struct link_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREvalue2:
		soap_serialize_ns1__link_USCOREvalue2(soap, (const struct ns1__link_USCOREvalue2 *)ptr);
		break;
	case SOAP_TYPE_link_USCORElist:
		soap_serialize_link_USCORElist(soap, (const struct link_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCORElist2:
		soap_serialize_ns1__link_USCORElist2(soap, (const struct ns1__link_USCORElist2 *)ptr);
		break;
	case SOAP_TYPE_ns1__acl_USCORElist_USCOREentry:
		soap_serialize_ns1__acl_USCORElist_USCOREentry(soap, (const struct ns1__acl_USCORElist_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_acl_USCORElist:
		soap_serialize_acl_USCORElist(soap, (const struct acl_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__module_USCORElist_USCOREentry:
		soap_serialize_ns1__module_USCORElist_USCOREentry(soap, (const struct ns1__module_USCORElist_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry:
		soap_serialize_ns1__last_USCOREviewed_USCOREentry(soap, (const struct ns1__last_USCOREviewed_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry:
		soap_serialize_ns1__upcoming_USCOREactivity_USCOREentry(soap, (const struct ns1__upcoming_USCOREactivity_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, (const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_module_USCORElist_USCOREarray:
		soap_serialize_module_USCORElist_USCOREarray(soap, (const struct module_USCORElist_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_ns1__module_USCORElist:
		soap_serialize_ns1__module_USCORElist(soap, (const struct ns1__module_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		soap_serialize_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, (const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__document_USCORErevision:
		soap_serialize_ns1__document_USCORErevision(soap, (const struct ns1__document_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, (const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, (const struct ns1__new_USCOREset_USCOREentries_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, (const struct ns1__new_USCOREset_USCOREentry_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		soap_serialize_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, (const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)ptr);
		break;
	case SOAP_TYPE_search_USCORElink_USCORElist:
		soap_serialize_search_USCORElink_USCORElist(soap, (const struct search_USCORElink_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		soap_serialize_ns1__return_USCOREsearch_USCOREresult(soap, (const struct ns1__return_USCOREsearch_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_link_USCORElists:
		soap_serialize_link_USCORElists(soap, (const struct link_USCORElists *)ptr);
		break;
	case SOAP_TYPE_entry_USCORElist:
		soap_serialize_entry_USCORElist(soap, (const struct entry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		soap_serialize_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, (const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)ptr);
		break;
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		soap_serialize_link_USCOREarray_USCORElist(soap, (const struct link_USCOREarray_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		soap_serialize_ns1__link_USCOREname_USCOREvalue(soap, (const struct ns1__link_USCOREname_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_select_USCOREfields:
		soap_serialize_select_USCOREfields(soap, (const struct select_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, (const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		soap_serialize_name_USCOREvalue_USCORElists(soap, (const struct name_USCOREvalue_USCORElists *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		soap_serialize_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, (const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		soap_serialize_ns1__entry_USCOREvalue(soap, (const struct ns1__entry_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		soap_serialize_link_USCOREfield_USCORElist(soap, (const struct link_USCOREfield_USCORElist *)ptr);
		break;
	case SOAP_TYPE_field_USCORElist:
		soap_serialize_field_USCORElist(soap, (const struct field_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		soap_serialize_ns1__new_USCOREmodule_USCOREfields(soap, (const struct ns1__new_USCOREmodule_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__name_USCOREvalue:
		soap_serialize_ns1__name_USCOREvalue(soap, (const struct ns1__name_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREfield:
		soap_serialize_ns1__link_USCOREfield(soap, (const struct ns1__link_USCOREfield *)ptr);
		break;
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		soap_serialize_name_USCOREvalue_USCORElist(soap, (const struct name_USCOREvalue_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__field:
		soap_serialize_ns1__field(soap, (const struct ns1__field *)ptr);
		break;
	case SOAP_TYPE_ns1__user_USCOREauth:
		soap_serialize_ns1__user_USCOREauth(soap, (const struct ns1__user_USCOREauth *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		soap_serialize_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, (const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		soap_serialize_ns1__new_USCOREnote_USCOREattachment(soap, (const struct ns1__new_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(soap, (struct ns1__get_USCOREmodified_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREresult:
		soap_serialize_PointerTons1__modified_USCORErelationship_USCOREresult(soap, (struct ns1__modified_USCORErelationship_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse:
		soap_serialize_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(soap, (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToupcoming_USCOREactivities_USCORElist:
		soap_serialize_PointerToupcoming_USCOREactivities_USCORElist(soap, (struct upcoming_USCOREactivities_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCORElast_USCOREviewedResponse:
		soap_serialize_PointerTons1__get_USCORElast_USCOREviewedResponse(soap, (struct ns1__get_USCORElast_USCOREviewedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomodule_USCOREnames:
		soap_serialize_PointerTomodule_USCOREnames(soap, (struct module_USCOREnames *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolast_USCOREviewed_USCORElist:
		soap_serialize_PointerTolast_USCOREviewed_USCORElist(soap, (struct last_USCOREviewed_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response:
		soap_serialize_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomd5_USCOREresults:
		soap_serialize_PointerTomd5_USCOREresults(soap, (struct md5_USCOREresults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		soap_serialize_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, (struct ns1__get_USCOREentries_USCOREcountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		soap_serialize_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, (struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		soap_serialize_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, (struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		soap_serialize_PointerTons1__module_USCORElist(soap, (struct ns1__module_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		soap_serialize_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, (struct ns1__search_USCOREby_USCOREmoduleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__return_USCOREsearch_USCOREresult:
		soap_serialize_PointerTons1__return_USCOREsearch_USCOREresult(soap, (struct ns1__return_USCOREsearch_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		soap_serialize_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, (struct ns1__get_USCOREdocument_USCORErevisionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision:
		soap_serialize_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		soap_serialize_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, (struct ns1__set_USCOREdocument_USCORErevisionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		soap_serialize_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, (struct ns1__get_USCOREnote_USCOREattachmentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment:
		soap_serialize_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		soap_serialize_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, (struct ns1__set_USCOREnote_USCOREattachmentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		soap_serialize_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, (struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREmodule_USCOREfields:
		soap_serialize_PointerTons1__new_USCOREmodule_USCOREfields(soap, (struct ns1__new_USCOREmodule_USCOREfields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfoResponse:
		soap_serialize_PointerTons1__get_USCOREserver_USCOREinfoResponse(soap, (struct ns1__get_USCOREserver_USCOREinfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		soap_serialize_PointerTons1__set_USCOREentriesResponse(soap, (struct ns1__set_USCOREentriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentries_USCOREresult:
		soap_serialize_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, (struct ns1__new_USCOREset_USCOREentries_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		soap_serialize_PointerTons1__set_USCOREentryResponse(soap, (struct ns1__set_USCOREentryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentry_USCOREresult:
		soap_serialize_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, (struct ns1__new_USCOREset_USCOREentry_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__get_USCORErelationshipsResponse(soap, (struct ns1__get_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__set_USCORErelationshipsResponse(soap, (struct ns1__set_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodeleted_USCOREarray:
		soap_serialize_PointerTodeleted_USCOREarray(soap, (struct deleted_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTonew_USCOREset_USCORErelationhip_USCOREids:
		soap_serialize_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, (struct new_USCOREset_USCORErelationhip_USCOREids *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		soap_serialize_PointerTons1__set_USCORErelationshipResponse(soap, (struct ns1__set_USCORErelationshipResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		soap_serialize_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		soap_serialize_PointerTons1__get_USCOREentry_USCORElistResponse(soap, (struct ns1__get_USCOREentry_USCORElistResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		soap_serialize_PointerTons1__get_USCOREentriesResponse(soap, (struct ns1__get_USCOREentriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		soap_serialize_PointerTons1__get_USCOREentryResponse(soap, (struct ns1__get_USCOREentryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2:
		soap_serialize_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logoutResponse:
		soap_serialize_PointerTons1__logoutResponse(soap, (struct ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginResponse:
		soap_serialize_PointerTons1__loginResponse(soap, (struct ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		soap_serialize_PointerTons1__user_USCOREauth(soap, (struct ns1__user_USCOREauth *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__modified_USCORErelationship_USCOREentry:
		soap_serialize_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(soap, (struct ns1__modified_USCORErelationship_USCOREentry **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry:
		soap_serialize_PointerTons1__modified_USCORErelationship_USCOREentry(soap, (struct ns1__modified_USCORErelationship_USCOREentry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		soap_serialize_PointerToPointerTolink_USCOREvalue(soap, (struct link_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		soap_serialize_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, (struct ns1__search_USCORElink_USCOREname_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue:
		soap_serialize_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, (struct ns1__search_USCORElink_USCOREname_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__entry_USCORElist2:
		soap_serialize_PointerToPointerTons1__entry_USCORElist2(soap, (struct ns1__entry_USCORElist2 **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__entry_USCORElist2:
		soap_serialize_PointerTons1__entry_USCORElist2(soap, (struct ns1__entry_USCORElist2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__field_USCORElist2:
		soap_serialize_PointerToPointerTons1__field_USCORElist2(soap, (struct ns1__field_USCORElist2 **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__field_USCORElist2:
		soap_serialize_PointerTons1__field_USCORElist2(soap, (struct ns1__field_USCORElist2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__acl_USCORElist_USCOREentry:
		soap_serialize_PointerToPointerTons1__acl_USCORElist_USCOREentry(soap, (struct ns1__acl_USCORElist_USCOREentry **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry:
		soap_serialize_PointerTons1__acl_USCORElist_USCOREentry(soap, (struct ns1__acl_USCORElist_USCOREentry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__module_USCORElist_USCOREentry:
		soap_serialize_PointerToPointerTons1__module_USCORElist_USCOREentry(soap, (struct ns1__module_USCORElist_USCOREentry **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry:
		soap_serialize_PointerTons1__module_USCORElist_USCOREentry(soap, (struct ns1__module_USCORElist_USCOREentry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__last_USCOREviewed_USCOREentry:
		soap_serialize_PointerToPointerTons1__last_USCOREviewed_USCOREentry(soap, (struct ns1__last_USCOREviewed_USCOREentry **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry:
		soap_serialize_PointerTons1__last_USCOREviewed_USCOREentry(soap, (struct ns1__last_USCOREviewed_USCOREentry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry:
		soap_serialize_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(soap, (struct ns1__upcoming_USCOREactivity_USCOREentry **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry:
		soap_serialize_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, (struct ns1__upcoming_USCOREactivity_USCOREentry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		soap_serialize_PointerToPointerToselect_USCOREfields(soap, (struct select_USCOREfields **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCORElist2:
		soap_serialize_PointerToPointerTons1__link_USCORElist2(soap, (struct ns1__link_USCORElist2 **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCORElist2:
		soap_serialize_PointerTons1__link_USCORElist2(soap, (struct ns1__link_USCORElist2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, (struct ns1__link_USCOREname_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, (struct ns1__link_USCOREname_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREvalue2:
		soap_serialize_PointerToPointerTons1__link_USCOREvalue2(soap, (struct ns1__link_USCOREvalue2 **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREvalue2:
		soap_serialize_PointerTons1__link_USCOREvalue2(soap, (struct ns1__link_USCOREvalue2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		soap_serialize_PointerToPointerTons1__entry_USCOREvalue(soap, (struct ns1__entry_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		soap_serialize_PointerTons1__entry_USCOREvalue(soap, (struct ns1__entry_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		soap_serialize_PointerToPointerToname_USCOREvalue_USCORElist(soap, (struct name_USCOREvalue_USCORElist **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		soap_serialize_PointerToPointerTons1__name_USCOREvalue(soap, (struct ns1__name_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		soap_serialize_PointerTons1__name_USCOREvalue(soap, (struct ns1__name_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		soap_serialize_PointerToPointerTons1__link_USCOREfield(soap, (struct ns1__link_USCOREfield **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		soap_serialize_PointerTons1__link_USCOREfield(soap, (struct ns1__link_USCOREfield *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__field:
		soap_serialize_PointerToPointerTons1__field(soap, (struct ns1__field **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__field:
		soap_serialize_PointerTons1__field(soap, (struct ns1__field *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		soap_serialize_PointerTons1__error_USCOREvalue(soap, (struct ns1__error_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomodified_USCORErelationship_USCOREentry_USCORElist:
		soap_serialize_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, (struct modified_USCORErelationship_USCOREentry_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosearch_USCORElink_USCOREarray_USCORElist:
		soap_serialize_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, (struct search_USCORElink_USCOREarray_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		soap_serialize_PointerTolink_USCOREvalue(soap, (struct link_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCORElist:
		soap_serialize_PointerTolink_USCORElist(soap, (struct link_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacl_USCORElist:
		soap_serialize_PointerToacl_USCORElist(soap, (struct acl_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomodule_USCORElist_USCOREarray:
		soap_serialize_PointerTomodule_USCORElist_USCOREarray(soap, (struct module_USCORElist_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		soap_serialize_PointerTons1__document_USCORErevision(soap, (struct ns1__document_USCORErevision *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosearch_USCORElink_USCORElist:
		soap_serialize_PointerTosearch_USCORElink_USCORElist(soap, (struct search_USCORElink_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCORElists:
		soap_serialize_PointerTolink_USCORElists(soap, (struct link_USCORElists *const*)ptr);
		break;
	case SOAP_TYPE_PointerToentry_USCORElist:
		soap_serialize_PointerToentry_USCORElist(soap, (struct entry_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		soap_serialize_PointerTolink_USCOREarray_USCORElist(soap, (struct link_USCOREarray_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerToselect_USCOREfields:
		soap_serialize_PointerToselect_USCOREfields(soap, (struct select_USCOREfields *const*)ptr);
		break;
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, (struct name_USCOREvalue_USCORElists *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		soap_serialize_PointerTolink_USCOREfield_USCORElist(soap, (struct link_USCOREfield_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofield_USCORElist:
		soap_serialize_PointerTofield_USCORElist(soap, (struct field_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, (struct name_USCOREvalue_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(soap, (struct ns1__new_USCOREnote_USCOREattachment *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->related_USCOREmodule);
	soap_default_string(soap, &a->from_USCOREdate);
	soap_default_string(soap, &a->to_USCOREdate);
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->max_USCOREresults);
	soap_default_int(soap, &a->deleted);
	soap_default_string(soap, &a->module_USCOREuser_USCOREid);
	a->select_USCOREfields = NULL;
	soap_default_string(soap, &a->relationship_USCOREname);
	soap_default_string(soap, &a->deletion_USCOREdate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, const struct ns1__get_USCOREmodified_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->related_USCOREmodule);
	soap_serialize_string(soap, &a->from_USCOREdate);
	soap_serialize_string(soap, &a->to_USCOREdate);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->module_USCOREuser_USCOREid);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_serialize_string(soap, &a->relationship_USCOREname);
	soap_serialize_string(soap, &a->deletion_USCOREdate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodified_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module", -1, &a->related_USCOREmodule, ""))
		return soap->error;
	if (soap_out_string(soap, "from_date", -1, &a->from_USCOREdate, ""))
		return soap->error;
	if (soap_out_string(soap, "to_date", -1, &a->to_USCOREdate, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	if (soap_out_string(soap, "module_user_id", -1, &a->module_USCOREuser_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_string(soap, "relationship_name", -1, &a->relationship_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "deletion_date", -1, &a->deletion_USCOREdate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationships * SOAP_FMAC4 soap_in_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCORErelationships *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_related_USCOREmodule = 1;
	size_t soap_flag_from_USCOREdate = 1;
	size_t soap_flag_to_USCOREdate = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_max_USCOREresults = 1;
	size_t soap_flag_deleted = 1;
	size_t soap_flag_module_USCOREuser_USCOREid = 1;
	size_t soap_flag_select_USCOREfields = 1;
	size_t soap_flag_relationship_USCOREname = 1;
	size_t soap_flag_deletion_USCOREdate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodified_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships, sizeof(struct ns1__get_USCOREmodified_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodified_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_related_USCOREmodule && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module", &a->related_USCOREmodule, "xsd:string"))
				{	soap_flag_related_USCOREmodule--;
					continue;
				}
			if (soap_flag_from_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "from_date", &a->from_USCOREdate, "xsd:string"))
				{	soap_flag_from_USCOREdate--;
					continue;
				}
			if (soap_flag_to_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "to_date", &a->to_USCOREdate, "xsd:string"))
				{	soap_flag_to_USCOREdate--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_module_USCOREuser_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_user_id", &a->module_USCOREuser_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREuser_USCOREid--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_relationship_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "relationship_name", &a->relationship_USCOREname, "xsd:string"))
				{	soap_flag_relationship_USCOREname--;
					continue;
				}
			if (soap_flag_deletion_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "deletion_date", &a->deletion_USCOREdate, "xsd:string"))
				{	soap_flag_deletion_USCOREdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships, 0, sizeof(struct ns1__get_USCOREmodified_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0 || soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, const struct ns1__get_USCOREmodified_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationships);
	if (soap_out_ns1__get_USCOREmodified_USCORErelationships(soap, tag?tag:"ns1:get_modified_relationships", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationships * SOAP_FMAC4 soap_get_ns1__get_USCOREmodified_USCORErelationships(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodified_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCOREmodified_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modified_USCORErelationship_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodified_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__modified_USCORErelationship_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodified_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse, sizeof(struct ns1__get_USCOREmodified_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modified_USCORErelationship_USCOREresult(soap, "return", &a->return_, "ns1:modified_relationship_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse, 0, sizeof(struct ns1__get_USCOREmodified_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCOREmodified_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse);
	if (soap_out_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag?tag:"ns1:get_modified_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, const struct ns1__get_USCOREupcoming_USCOREactivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREupcoming_USCOREactivities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivities * SOAP_FMAC4 soap_in_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, const char *tag, struct ns1__get_USCOREupcoming_USCOREactivities *a, const char *type)
{
	size_t soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREupcoming_USCOREactivities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities, sizeof(struct ns1__get_USCOREupcoming_USCOREactivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREupcoming_USCOREactivities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREupcoming_USCOREactivities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities, 0, sizeof(struct ns1__get_USCOREupcoming_USCOREactivities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, const struct ns1__get_USCOREupcoming_USCOREactivities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivities);
	if (soap_out_ns1__get_USCOREupcoming_USCOREactivities(soap, tag?tag:"ns1:get_upcoming_activities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivities * SOAP_FMAC4 soap_get_ns1__get_USCOREupcoming_USCOREactivities(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREupcoming_USCOREactivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToupcoming_USCOREactivities_USCORElist(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse), type))
		return soap->error;
	if (soap_out_PointerToupcoming_USCOREactivities_USCORElist(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivitiesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse, sizeof(struct ns1__get_USCOREupcoming_USCOREactivitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToupcoming_USCOREactivities_USCORElist(soap, "return", &a->return_, "ns1:upcoming_activity_entry"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse, 0, sizeof(struct ns1__get_USCOREupcoming_USCOREactivitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse);
	if (soap_out_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag?tag:"ns1:get_upcoming_activitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivitiesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElast_USCOREviewed(struct soap *soap, struct ns1__get_USCORElast_USCOREviewed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->module_USCOREnames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElast_USCOREviewed(struct soap *soap, const struct ns1__get_USCORElast_USCOREviewed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTomodule_USCOREnames(soap, &a->module_USCOREnames);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElast_USCOREviewed(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElast_USCOREviewed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewed), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTomodule_USCOREnames(soap, "module_names", -1, &a->module_USCOREnames, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewed * SOAP_FMAC4 soap_in_ns1__get_USCORElast_USCOREviewed(struct soap *soap, const char *tag, struct ns1__get_USCORElast_USCOREviewed *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREnames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORElast_USCOREviewed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewed, sizeof(struct ns1__get_USCORElast_USCOREviewed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElast_USCOREviewed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREnames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomodule_USCOREnames(soap, "module_names", &a->module_USCOREnames, "xsd:string"))
				{	soap_flag_module_USCOREnames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElast_USCOREviewed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORElast_USCOREviewed, 0, sizeof(struct ns1__get_USCORElast_USCOREviewed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElast_USCOREviewed(struct soap *soap, const struct ns1__get_USCORElast_USCOREviewed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElast_USCOREviewed);
	if (soap_out_ns1__get_USCORElast_USCOREviewed(soap, tag?tag:"ns1:get_last_viewed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewed * SOAP_FMAC4 soap_get_ns1__get_USCORElast_USCOREviewed(struct soap *soap, struct ns1__get_USCORElast_USCOREviewed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElast_USCOREviewed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, struct ns1__get_USCORElast_USCOREviewedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const struct ns1__get_USCORElast_USCOREviewedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolast_USCOREviewed_USCORElist(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElast_USCOREviewedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse), type))
		return soap->error;
	if (soap_out_PointerTolast_USCOREviewed_USCORElist(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewedResponse * SOAP_FMAC4 soap_in_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const char *tag, struct ns1__get_USCORElast_USCOREviewedResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORElast_USCOREviewedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse, sizeof(struct ns1__get_USCORElast_USCOREviewedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElast_USCOREviewedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolast_USCOREviewed_USCORElist(soap, "return", &a->return_, "ns1:last_viewed_entry"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElast_USCOREviewedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse, 0, sizeof(struct ns1__get_USCORElast_USCOREviewedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const struct ns1__get_USCORElast_USCOREviewedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse);
	if (soap_out_ns1__get_USCORElast_USCOREviewedResponse(soap, tag?tag:"ns1:get_last_viewedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewedResponse * SOAP_FMAC4 soap_get_ns1__get_USCORElast_USCOREviewedResponse(struct soap *soap, struct ns1__get_USCORElast_USCOREviewedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElast_USCOREviewedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->module_USCOREnames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->module_USCOREnames);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "module_names", -1, &a->module_USCOREnames, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREnames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREnames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "module_names", &a->module_USCOREnames, "xsd:string"))
				{	soap_flag_module_USCOREnames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5);
	if (soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, tag?tag:"ns1:get_module_fields_md5", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTomd5_USCOREresults(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response), type))
		return soap->error;
	if (soap_out_PointerTomd5_USCOREresults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomd5_USCOREresults(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response);
	if (soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag?tag:"ns1:get_module_fields_md5Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcount(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->query);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->query);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "query", -1, &a->query, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_query = 1;
	size_t soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount, sizeof(struct ns1__get_USCOREentries_USCOREcount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_query && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "query", &a->query, "xsd:string"))
				{	soap_flag_query--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount, 0, sizeof(struct ns1__get_USCOREentries_USCOREcount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount);
	if (soap_out_ns1__get_USCOREentries_USCOREcount(soap, tag?tag:"ns1:get_entries_count", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcount(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, "return", &a->return_, "ns1:get_entries_count_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, 0, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse);
	if (soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag?tag:"ns1:get_entries_countResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmerge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->targets = NULL;
	soap_default_string(soap, &a->campaign_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmerge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->targets);
	soap_serialize_string(soap, &a->campaign_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "targets", -1, &a->targets, ""))
		return soap->error;
	if (soap_out_string(soap, "campaign_id", -1, &a->campaign_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmerge * SOAP_FMAC4 soap_in_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_targets = 1;
	size_t soap_flag_campaign_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREcampaign_USCOREmerge *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge, sizeof(struct ns1__set_USCOREcampaign_USCOREmerge), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREcampaign_USCOREmerge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_targets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "targets", &a->targets, "xsd:string"))
				{	soap_flag_targets--;
					continue;
				}
			if (soap_flag_campaign_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaign_id", &a->campaign_USCOREid, "xsd:string"))
				{	soap_flag_campaign_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmerge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge, 0, sizeof(struct ns1__set_USCOREcampaign_USCOREmerge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge);
	if (soap_out_ns1__set_USCOREcampaign_USCOREmerge(soap, tag?tag:"ns1:set_campaign_merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmerge * SOAP_FMAC4 soap_get_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmerge *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, 0, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse);
	if (soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag?tag:"ns1:set_campaign_mergeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREid * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *type)
{
	size_t soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid, 0, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid);
	if (soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag?tag:"ns1:get_user_team_id", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREid * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse, 0, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse);
	if (soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag?tag:"ns1:get_user_team_idResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->filter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->filter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREavailable_USCOREmodules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "filter", -1, &a->filter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodules * SOAP_FMAC4 soap_in_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodules *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_filter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREavailable_USCOREmodules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules, sizeof(struct ns1__get_USCOREavailable_USCOREmodules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREavailable_USCOREmodules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_filter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filter", &a->filter, "xsd:string"))
				{	soap_flag_filter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules, 0, sizeof(struct ns1__get_USCOREavailable_USCOREmodules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules);
	if (soap_out_ns1__get_USCOREavailable_USCOREmodules(soap, tag?tag:"ns1:get_available_modules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodules * SOAP_FMAC4 soap_get_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__module_USCORElist(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__module_USCORElist(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__module_USCORElist(soap, "return", &a->return_, "ns1:module_list"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, 0, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse);
	if (soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag?tag:"ns1:get_available_modulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search_USCOREby_USCOREmodule(struct soap *soap, struct ns1__search_USCOREby_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->search_USCOREstring);
	a->modules = NULL;
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->max_USCOREresults);
	soap_default_string(soap, &a->assigned_USCOREuser_USCOREid);
	a->select_USCOREfields = NULL;
	soap_default_xsd__boolean(soap, &a->unified_USCOREsearch_USCOREonly);
	soap_default_xsd__boolean(soap, &a->favorites);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const struct ns1__search_USCOREby_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->search_USCOREstring);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->modules);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->assigned_USCOREuser_USCOREid);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const char *tag, int id, const struct ns1__search_USCOREby_USCOREmodule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "search_string", -1, &a->search_USCOREstring, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "modules", -1, &a->modules, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	if (soap_out_string(soap, "assigned_user_id", -1, &a->assigned_USCOREuser_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "unified_search_only", -1, &a->unified_USCOREsearch_USCOREonly, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "favorites", -1, &a->favorites, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmodule * SOAP_FMAC4 soap_in_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmodule *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_search_USCOREstring = 1;
	size_t soap_flag_modules = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_max_USCOREresults = 1;
	size_t soap_flag_assigned_USCOREuser_USCOREid = 1;
	size_t soap_flag_select_USCOREfields = 1;
	size_t soap_flag_unified_USCOREsearch_USCOREonly = 1;
	size_t soap_flag_favorites = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search_USCOREby_USCOREmodule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule, sizeof(struct ns1__search_USCOREby_USCOREmodule), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search_USCOREby_USCOREmodule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_search_USCOREstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "search_string", &a->search_USCOREstring, "xsd:string"))
				{	soap_flag_search_USCOREstring--;
					continue;
				}
			if (soap_flag_modules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "modules", &a->modules, "xsd:string"))
				{	soap_flag_modules--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap_flag_assigned_USCOREuser_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "assigned_user_id", &a->assigned_USCOREuser_USCOREid, "xsd:string"))
				{	soap_flag_assigned_USCOREuser_USCOREid--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_unified_USCOREsearch_USCOREonly && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "unified_search_only", &a->unified_USCOREsearch_USCOREonly, "xsd:boolean"))
				{	soap_flag_unified_USCOREsearch_USCOREonly--;
					continue;
				}
			if (soap_flag_favorites && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "favorites", &a->favorites, "xsd:boolean"))
				{	soap_flag_favorites--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmodule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule, 0, sizeof(struct ns1__search_USCOREby_USCOREmodule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0 || soap_flag_unified_USCOREsearch_USCOREonly > 0 || soap_flag_favorites > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const struct ns1__search_USCOREby_USCOREmodule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule);
	if (soap_out_ns1__search_USCOREby_USCOREmodule(soap, tag?tag:"ns1:search_by_module", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmodule * SOAP_FMAC4 soap_get_ns1__search_USCOREby_USCOREmodule(struct soap *soap, struct ns1__search_USCOREby_USCOREmodule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search_USCOREby_USCOREmodule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const struct ns1__search_USCOREby_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__return_USCOREsearch_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__return_USCOREsearch_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse * SOAP_FMAC4 soap_in_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search_USCOREby_USCOREmoduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search_USCOREby_USCOREmoduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__return_USCOREsearch_USCOREresult(soap, "return", &a->return_, "ns1:return_search_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmoduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, 0, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse);
	if (soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag?tag:"ns1:search_by_moduleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse * SOAP_FMAC4 soap_get_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->i);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "i", -1, &a->i, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevision *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_i = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision, sizeof(struct ns1__get_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_i && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "i", &a->i, "xsd:string"))
				{	soap_flag_i--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__get_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision);
	if (soap_out_ns1__get_USCOREdocument_USCORErevision(soap, tag?tag:"ns1:get_document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREdocument_USCORErevisionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, "return", &a->return_, "ns1:new_return_document_revision"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, 0, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse);
	if (soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag?tag:"ns1:get_document_revisionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTons1__document_USCORErevision(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTons1__document_USCORErevision(soap, "note", -1, &a->note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevision *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision, sizeof(struct ns1__set_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__document_USCORErevision(soap, "note", &a->note, "ns1:document_revision"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__set_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision);
	if (soap_out_ns1__set_USCOREdocument_USCORErevision(soap, tag?tag:"ns1:set_document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREdocument_USCORErevisionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:new_set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, 0, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse);
	if (soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag?tag:"ns1:set_document_revisionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachment *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment, sizeof(struct ns1__get_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__get_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment);
	if (soap_out_ns1__get_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:get_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnote_USCOREattachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, "return", &a->return_, "ns1:new_return_note_attachment"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, 0, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse);
	if (soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag?tag:"ns1:get_note_attachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note", -1, &a->note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachment *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment, sizeof(struct ns1__set_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note", &a->note, "ns1:new_note_attachment"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__set_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment);
	if (soap_out_ns1__set_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:set_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREnote_USCOREattachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:new_set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, 0, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse);
	if (soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag?tag:"ns1:set_note_attachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__seamless_USCORElogin(struct soap *soap, struct ns1__seamless_USCORElogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__seamless_USCORElogin(struct soap *soap, const struct ns1__seamless_USCORElogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__seamless_USCORElogin(struct soap *soap, const char *tag, int id, const struct ns1__seamless_USCORElogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__seamless_USCORElogin), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__seamless_USCORElogin * SOAP_FMAC4 soap_in_ns1__seamless_USCORElogin(struct soap *soap, const char *tag, struct ns1__seamless_USCORElogin *a, const char *type)
{
	size_t soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__seamless_USCORElogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__seamless_USCORElogin, sizeof(struct ns1__seamless_USCORElogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__seamless_USCORElogin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__seamless_USCORElogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__seamless_USCORElogin, 0, sizeof(struct ns1__seamless_USCORElogin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__seamless_USCORElogin(struct soap *soap, const struct ns1__seamless_USCORElogin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__seamless_USCORElogin);
	if (soap_out_ns1__seamless_USCORElogin(soap, tag?tag:"ns1:seamless_login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__seamless_USCORElogin * SOAP_FMAC4 soap_get_ns1__seamless_USCORElogin(struct soap *soap, struct ns1__seamless_USCORElogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__seamless_USCORElogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__seamless_USCOREloginResponse(struct soap *soap, struct ns1__seamless_USCOREloginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__seamless_USCOREloginResponse(struct soap *soap, const struct ns1__seamless_USCOREloginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__seamless_USCOREloginResponse(struct soap *soap, const char *tag, int id, const struct ns1__seamless_USCOREloginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__seamless_USCOREloginResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__seamless_USCOREloginResponse * SOAP_FMAC4 soap_in_ns1__seamless_USCOREloginResponse(struct soap *soap, const char *tag, struct ns1__seamless_USCOREloginResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__seamless_USCOREloginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__seamless_USCOREloginResponse, sizeof(struct ns1__seamless_USCOREloginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__seamless_USCOREloginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__seamless_USCOREloginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__seamless_USCOREloginResponse, 0, sizeof(struct ns1__seamless_USCOREloginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__seamless_USCOREloginResponse(struct soap *soap, const struct ns1__seamless_USCOREloginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__seamless_USCOREloginResponse);
	if (soap_out_ns1__seamless_USCOREloginResponse(soap, tag?tag:"ns1:seamless_loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__seamless_USCOREloginResponse * SOAP_FMAC4 soap_get_ns1__seamless_USCOREloginResponse(struct soap *soap, struct ns1__seamless_USCOREloginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__seamless_USCOREloginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->fields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->fields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "fields", -1, &a->fields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfields *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_fields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields, sizeof(struct ns1__get_USCOREmodule_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_fields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "fields", &a->fields, "xsd:string"))
				{	soap_flag_fields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields);
	if (soap_out_ns1__get_USCOREmodule_USCOREfields(soap, tag?tag:"ns1:get_module_fields", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREmodule_USCOREfields(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREmodule_USCOREfields(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREmodule_USCOREfields(soap, "return", &a->return_, "ns1:new_module_fields"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse);
	if (soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag?tag:"ns1:get_module_fieldsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREid(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREid), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREid * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREid(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREid *a, const char *type)
{
	size_t soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREid, sizeof(struct ns1__get_USCOREuser_USCOREid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREid, 0, sizeof(struct ns1__get_USCOREuser_USCOREid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREid);
	if (soap_out_ns1__get_USCOREuser_USCOREid(soap, tag?tag:"ns1:get_user_id", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREid * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREidResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREidResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse, sizeof(struct ns1__get_USCOREuser_USCOREidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse, 0, sizeof(struct ns1__get_USCOREuser_USCOREidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse);
	if (soap_out_ns1__get_USCOREuser_USCOREidResponse(soap, tag?tag:"ns1:get_user_idResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREidResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREinfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREinfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo, sizeof(struct ns1__get_USCOREserver_USCOREinfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREinfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo, 0, sizeof(struct ns1__get_USCOREserver_USCOREinfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo);
	if (soap_out_ns1__get_USCOREserver_USCOREinfo(soap, tag?tag:"ns1:get_server_info", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREinfo(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREinfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREinfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfoResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREinfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse, sizeof(struct ns1__get_USCOREserver_USCOREinfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREinfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, "return", &a->return_, "ns1:get_server_info_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse, 0, sizeof(struct ns1__get_USCOREserver_USCOREinfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse);
	if (soap_out_ns1__get_USCOREserver_USCOREinfoResponse(soap, tag?tag:"ns1:get_server_infoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfoResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREinfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries(struct soap *soap, struct ns1__set_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElists = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries(struct soap *soap, const struct ns1__set_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries * SOAP_FMAC4 soap_in_ns1__set_USCOREentries(struct soap *soap, const char *tag, struct ns1__set_USCOREentries *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_name_USCOREvalue_USCORElists = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries, sizeof(struct ns1__set_USCOREentries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries, 0, sizeof(struct ns1__set_USCOREentries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries(struct soap *soap, const struct ns1__set_USCOREentries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries);
	if (soap_out_ns1__set_USCOREentries(soap, tag?tag:"ns1:set_entries", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentries * SOAP_FMAC4 soap_get_ns1__set_USCOREentries(struct soap *soap, struct ns1__set_USCOREentries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentriesResponse(struct soap *soap, const struct ns1__set_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentriesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentriesResponse, sizeof(struct ns1__set_USCOREentriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, "return", &a->return_, "ns1:new_set_entries_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentriesResponse, 0, sizeof(struct ns1__set_USCOREentriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentriesResponse(struct soap *soap, const struct ns1__set_USCOREentriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentriesResponse);
	if (soap_out_ns1__set_USCOREentriesResponse(soap, tag?tag:"ns1:set_entriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentry(struct soap *soap, struct ns1__set_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentry(struct soap *soap, const struct ns1__set_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentry * SOAP_FMAC4 soap_in_ns1__set_USCOREentry(struct soap *soap, const char *tag, struct ns1__set_USCOREentry *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentry, sizeof(struct ns1__set_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentry, 0, sizeof(struct ns1__set_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentry(struct soap *soap, const struct ns1__set_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentry);
	if (soap_out_ns1__set_USCOREentry(soap, tag?tag:"ns1:set_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentry * SOAP_FMAC4 soap_get_ns1__set_USCOREentry(struct soap *soap, struct ns1__set_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentryResponse(struct soap *soap, const struct ns1__set_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentryResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentryResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentryResponse, sizeof(struct ns1__set_USCOREentryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:new_set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentryResponse, 0, sizeof(struct ns1__set_USCOREentryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentryResponse(struct soap *soap, const struct ns1__set_USCOREentryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentryResponse);
	if (soap_out_ns1__set_USCOREentryResponse(soap, tag?tag:"ns1:set_entryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelationships(struct soap *soap, struct ns1__get_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->module_USCOREid);
	soap_default_string(soap, &a->link_USCOREfield_USCOREname);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREquery);
	a->related_USCOREfields = NULL;
	a->related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray = NULL;
	soap_default_int(soap, &a->deleted);
	soap_default_string(soap, &a->order_USCOREby);
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->limit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelationships(struct soap *soap, const struct ns1__get_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->module_USCOREid);
	soap_serialize_string(soap, &a->link_USCOREfield_USCOREname);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREquery);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->related_USCOREfields);
	soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, &a->related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->order_USCOREby);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->limit, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "link_field_name", -1, &a->link_USCOREfield_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_query", -1, &a->related_USCOREmodule_USCOREquery, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "related_fields", -1, &a->related_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "related_module_link_name_to_fields_array", -1, &a->related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	if (soap_out_string(soap, "order_by", -1, &a->order_USCOREby, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelationships * SOAP_FMAC4 soap_in_ns1__get_USCORErelationships(struct soap *soap, const char *tag, struct ns1__get_USCORErelationships *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_module_USCOREid = 1;
	size_t soap_flag_link_USCOREfield_USCOREname = 1;
	size_t soap_flag_related_USCOREmodule_USCOREquery = 1;
	size_t soap_flag_related_USCOREfields = 1;
	size_t soap_flag_related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray = 1;
	size_t soap_flag_deleted = 1;
	size_t soap_flag_order_USCOREby = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_limit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelationships, sizeof(struct ns1__get_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap_flag_link_USCOREfield_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "link_field_name", &a->link_USCOREfield_USCOREname, "xsd:string"))
				{	soap_flag_link_USCOREfield_USCOREname--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREquery && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_query", &a->related_USCOREmodule_USCOREquery, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREquery--;
					continue;
				}
			if (soap_flag_related_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "related_fields", &a->related_USCOREfields, "xsd:string"))
				{	soap_flag_related_USCOREfields--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "related_module_link_name_to_fields_array", &a->related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray, "ns1:link_name_to_fields_array"))
				{	soap_flag_related_USCOREmodule_USCORElink_USCOREname_USCOREto_USCOREfields_USCOREarray--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_order_USCOREby && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "order_by", &a->order_USCOREby, "xsd:string"))
				{	soap_flag_order_USCOREby--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "limit", &a->limit, "xsd:int"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelationships, 0, sizeof(struct ns1__get_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleted > 0 || soap_flag_offset > 0 || soap_flag_limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelationships(struct soap *soap, const struct ns1__get_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelationships);
	if (soap_out_ns1__get_USCORErelationships(soap, tag?tag:"ns1:get_relationships", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORErelationships * SOAP_FMAC4 soap_get_ns1__get_USCORErelationships(struct soap *soap, struct ns1__get_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelationshipsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, sizeof(struct ns1__get_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", &a->return_, "ns1:get_entry_result_version2"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, 0, sizeof(struct ns1__get_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelationshipsResponse);
	if (soap_out_ns1__get_USCORErelationshipsResponse(soap, tag?tag:"ns1:get_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationships(struct soap *soap, struct ns1__set_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->module_USCOREnames = NULL;
	a->module_USCOREids = NULL;
	a->link_USCOREfield_USCOREnames = NULL;
	a->related_USCOREids = NULL;
	a->name_USCOREvalue_USCORElists = NULL;
	a->delete_USCOREarray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationships(struct soap *soap, const struct ns1__set_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->module_USCOREnames);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->module_USCOREids);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->link_USCOREfield_USCOREnames);
	soap_serialize_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, &a->related_USCOREids);
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
	soap_serialize_PointerTodeleted_USCOREarray(soap, &a->delete_USCOREarray);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "module_names", -1, &a->module_USCOREnames, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "module_ids", -1, &a->module_USCOREids, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "link_field_names", -1, &a->link_USCOREfield_USCOREnames, ""))
		return soap->error;
	if (soap_out_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, "related_ids", -1, &a->related_USCOREids, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	if (soap_out_PointerTodeleted_USCOREarray(soap, "delete_array", -1, &a->delete_USCOREarray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationships * SOAP_FMAC4 soap_in_ns1__set_USCORErelationships(struct soap *soap, const char *tag, struct ns1__set_USCORErelationships *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREnames = 1;
	size_t soap_flag_module_USCOREids = 1;
	size_t soap_flag_link_USCOREfield_USCOREnames = 1;
	size_t soap_flag_related_USCOREids = 1;
	size_t soap_flag_name_USCOREvalue_USCORElists = 1;
	size_t soap_flag_delete_USCOREarray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationships, sizeof(struct ns1__set_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREnames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "module_names", &a->module_USCOREnames, "xsd:string"))
				{	soap_flag_module_USCOREnames--;
					continue;
				}
			if (soap_flag_module_USCOREids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "module_ids", &a->module_USCOREids, "xsd:string"))
				{	soap_flag_module_USCOREids--;
					continue;
				}
			if (soap_flag_link_USCOREfield_USCOREnames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "link_field_names", &a->link_USCOREfield_USCOREnames, "xsd:string"))
				{	soap_flag_link_USCOREfield_USCOREnames--;
					continue;
				}
			if (soap_flag_related_USCOREids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, "related_ids", &a->related_USCOREids, "xsd:string"))
				{	soap_flag_related_USCOREids--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap_flag_delete_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodeleted_USCOREarray(soap, "delete_array", &a->delete_USCOREarray, "xsd:int"))
				{	soap_flag_delete_USCOREarray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationships, 0, sizeof(struct ns1__set_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationships(struct soap *soap, const struct ns1__set_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationships);
	if (soap_out_ns1__set_USCORErelationships(soap, tag?tag:"ns1:set_relationships", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationships * SOAP_FMAC4 soap_get_ns1__set_USCORErelationships(struct soap *soap, struct ns1__set_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationshipsResponse(struct soap *soap, const struct ns1__set_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, sizeof(struct ns1__set_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, "return", &a->return_, "ns1:new_set_relationship_list_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, 0, sizeof(struct ns1__set_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationshipsResponse(struct soap *soap, const struct ns1__set_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationshipsResponse);
	if (soap_out_ns1__set_USCORErelationshipsResponse(soap, tag?tag:"ns1:set_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationship(struct soap *soap, struct ns1__set_USCORErelationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->module_USCOREid);
	soap_default_string(soap, &a->link_USCOREfield_USCOREname);
	a->related_USCOREids = NULL;
	a->name_USCOREvalue_USCORElist = NULL;
	soap_default_int(soap, &a->delete_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationship(struct soap *soap, const struct ns1__set_USCORErelationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->module_USCOREid);
	soap_serialize_string(soap, &a->link_USCOREfield_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->related_USCOREids);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
	soap_embedded(soap, &a->delete_, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationship(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationship *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationship), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "link_field_name", -1, &a->link_USCOREfield_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "related_ids", -1, &a->related_USCOREids, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	if (soap_out_int(soap, "delete", -1, &a->delete_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship * SOAP_FMAC4 soap_in_ns1__set_USCORErelationship(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_module_USCOREid = 1;
	size_t soap_flag_link_USCOREfield_USCOREname = 1;
	size_t soap_flag_related_USCOREids = 1;
	size_t soap_flag_name_USCOREvalue_USCORElist = 1;
	size_t soap_flag_delete_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationship, sizeof(struct ns1__set_USCORErelationship), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationship(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap_flag_link_USCOREfield_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "link_field_name", &a->link_USCOREfield_USCOREname, "xsd:string"))
				{	soap_flag_link_USCOREfield_USCOREname--;
					continue;
				}
			if (soap_flag_related_USCOREids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "related_ids", &a->related_USCOREids, "xsd:string"))
				{	soap_flag_related_USCOREids--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap_flag_delete_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "delete", &a->delete_, "xsd:int"))
				{	soap_flag_delete_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationship, 0, sizeof(struct ns1__set_USCORErelationship), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delete_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationship(struct soap *soap, const struct ns1__set_USCORErelationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationship);
	if (soap_out_ns1__set_USCORErelationship(soap, tag?tag:"ns1:set_relationship", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship * SOAP_FMAC4 soap_get_ns1__set_USCORErelationship(struct soap *soap, struct ns1__set_USCORErelationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationshipResponse(struct soap *soap, const struct ns1__set_USCORErelationshipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationshipResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationshipResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse * SOAP_FMAC4 soap_in_ns1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationshipResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationshipResponse, sizeof(struct ns1__set_USCORErelationshipResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationshipResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, "return", &a->return_, "ns1:new_set_relationship_list_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationshipResponse, 0, sizeof(struct ns1__set_USCORErelationshipResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationshipResponse(struct soap *soap, const struct ns1__set_USCORErelationshipResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationshipResponse);
	if (soap_out_ns1__set_USCORErelationshipResponse(soap, tag?tag:"ns1:set_relationshipResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse * SOAP_FMAC4 soap_get_ns1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationshipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist(struct soap *soap, struct ns1__get_USCOREentry_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->query);
	soap_default_string(soap, &a->order_USCOREby);
	soap_default_int(soap, &a->offset);
	a->select_USCOREfields = NULL;
	a->link_USCOREname_USCOREto_USCOREfields_USCOREarray = NULL;
	soap_default_int(soap, &a->max_USCOREresults);
	soap_default_int(soap, &a->deleted);
	soap_default_xsd__boolean(soap, &a->favorites);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->query);
	soap_serialize_string(soap, &a->order_USCOREby);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "query", -1, &a->query, ""))
		return soap->error;
	if (soap_out_string(soap, "order_by", -1, &a->order_USCOREby, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", -1, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "favorites", -1, &a->favorites, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_query = 1;
	size_t soap_flag_order_USCOREby = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_select_USCOREfields = 1;
	size_t soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray = 1;
	size_t soap_flag_max_USCOREresults = 1;
	size_t soap_flag_deleted = 1;
	size_t soap_flag_favorites = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist, sizeof(struct ns1__get_USCOREentry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_query && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "query", &a->query, "xsd:string"))
				{	soap_flag_query--;
					continue;
				}
			if (soap_flag_order_USCOREby && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "order_by", &a->order_USCOREby, "xsd:string"))
				{	soap_flag_order_USCOREby--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, "ns1:link_name_to_fields_array"))
				{	soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_favorites && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "favorites", &a->favorites, "xsd:boolean"))
				{	soap_flag_favorites--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist, 0, sizeof(struct ns1__get_USCOREentry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0 || soap_flag_deleted > 0 || soap_flag_favorites > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist);
	if (soap_out_ns1__get_USCOREentry_USCORElist(soap, tag?tag:"ns1:get_entry_list", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist(struct soap *soap, struct ns1__get_USCOREentry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREentry_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElistResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, "return", &a->return_, "ns1:get_entry_list_result_version2"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, 0, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREentry_USCORElistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse);
	if (soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag?tag:"ns1:get_entry_listResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries(struct soap *soap, struct ns1__get_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->ids = NULL;
	a->select_USCOREfields = NULL;
	a->link_USCOREname_USCOREto_USCOREfields_USCOREarray = NULL;
	soap_default_xsd__boolean(soap, &a->track_USCOREview);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries(struct soap *soap, const struct ns1__get_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", -1, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "track_view", -1, &a->track_USCOREview, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries * SOAP_FMAC4 soap_in_ns1__get_USCOREentries(struct soap *soap, const char *tag, struct ns1__get_USCOREentries *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_ids = 1;
	size_t soap_flag_select_USCOREfields = 1;
	size_t soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray = 1;
	size_t soap_flag_track_USCOREview = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries, sizeof(struct ns1__get_USCOREentries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, "ns1:link_name_to_fields_array"))
				{	soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray--;
					continue;
				}
			if (soap_flag_track_USCOREview && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "track_view", &a->track_USCOREview, "xsd:boolean"))
				{	soap_flag_track_USCOREview--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries, 0, sizeof(struct ns1__get_USCOREentries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_track_USCOREview > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries(struct soap *soap, const struct ns1__get_USCOREentries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries);
	if (soap_out_ns1__get_USCOREentries(soap, tag?tag:"ns1:get_entries", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries * SOAP_FMAC4 soap_get_ns1__get_USCOREentries(struct soap *soap, struct ns1__get_USCOREentries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentriesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentriesResponse, sizeof(struct ns1__get_USCOREentriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", &a->return_, "ns1:get_entry_result_version2"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentriesResponse, 0, sizeof(struct ns1__get_USCOREentriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREentriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentriesResponse);
	if (soap_out_ns1__get_USCOREentriesResponse(soap, tag?tag:"ns1:get_entriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry(struct soap *soap, struct ns1__get_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->id);
	a->select_USCOREfields = NULL;
	a->link_USCOREname_USCOREto_USCOREfields_USCOREarray = NULL;
	soap_default_xsd__boolean(soap, &a->track_USCOREview);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry(struct soap *soap, const struct ns1__get_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->id);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", -1, &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "track_view", -1, &a->track_USCOREview, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry * SOAP_FMAC4 soap_in_ns1__get_USCOREentry(struct soap *soap, const char *tag, struct ns1__get_USCOREentry *a, const char *type)
{
	size_t soap_flag_session = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_select_USCOREfields = 1;
	size_t soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray = 1;
	size_t soap_flag_track_USCOREview = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry, sizeof(struct ns1__get_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, "link_name_to_fields_array", &a->link_USCOREname_USCOREto_USCOREfields_USCOREarray, "ns1:link_name_to_fields_array"))
				{	soap_flag_link_USCOREname_USCOREto_USCOREfields_USCOREarray--;
					continue;
				}
			if (soap_flag_track_USCOREview && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "track_view", &a->track_USCOREview, "xsd:boolean"))
				{	soap_flag_track_USCOREview--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry, 0, sizeof(struct ns1__get_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_track_USCOREview > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry(struct soap *soap, const struct ns1__get_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry);
	if (soap_out_ns1__get_USCOREentry(soap, tag?tag:"ns1:get_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry * SOAP_FMAC4 soap_get_ns1__get_USCOREentry(struct soap *soap, struct ns1__get_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentryResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentryResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentryResponse, sizeof(struct ns1__get_USCOREentryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, "return", &a->return_, "ns1:get_entry_result_version2"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentryResponse, 0, sizeof(struct ns1__get_USCOREentryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCOREentryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentryResponse);
	if (soap_out_ns1__get_USCOREentryResponse(soap, tag?tag:"ns1:get_entryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__logout(struct soap *soap, struct ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__logout(struct soap *soap, const struct ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const struct ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, struct ns1__logout *a, const char *type)
{
	size_t soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(struct ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__logout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, 0, sizeof(struct ns1__logout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__logout(struct soap *soap, const struct ns1__logout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__logout);
	if (soap_out_ns1__logout(soap, tag?tag:"ns1:logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, struct ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__logoutResponse(struct soap *soap, const struct ns1__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const struct ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, struct ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__logoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(struct ns1__logoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__logoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, 0, sizeof(struct ns1__logoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__logoutResponse(struct soap *soap, const struct ns1__logoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__logoutResponse);
	if (soap_out_ns1__logoutResponse(soap, tag?tag:"ns1:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__login(struct soap *soap, struct ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->user_USCOREauth = NULL;
	soap_default_string(soap, &a->application_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__login(struct soap *soap, const struct ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user_USCOREauth(soap, &a->user_USCOREauth);
	soap_serialize_string(soap, &a->application_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const struct ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__login), type))
		return soap->error;
	if (soap_out_PointerTons1__user_USCOREauth(soap, "user_auth", -1, &a->user_USCOREauth, ""))
		return soap->error;
	if (soap_out_string(soap, "application_name", -1, &a->application_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__login * SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, struct ns1__login *a, const char *type)
{
	size_t soap_flag_user_USCOREauth = 1;
	size_t soap_flag_application_USCOREname = 1;
	size_t soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__login, sizeof(struct ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREauth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user_USCOREauth(soap, "user_auth", &a->user_USCOREauth, "ns1:user_auth"))
				{	soap_flag_user_USCOREauth--;
					continue;
				}
			if (soap_flag_application_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "application_name", &a->application_USCOREname, "xsd:string"))
				{	soap_flag_application_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__login, 0, sizeof(struct ns1__login), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__login(struct soap *soap, const struct ns1__login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__login);
	if (soap_out_ns1__login(soap, tag?tag:"ns1:login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__login * SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, struct ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__loginResponse(struct soap *soap, struct ns1__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__loginResponse(struct soap *soap, const struct ns1__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__entry_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id, const struct ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__entry_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__loginResponse * SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag, struct ns1__loginResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginResponse, sizeof(struct ns1__loginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__loginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__entry_USCOREvalue(soap, "return", &a->return_, "ns1:entry_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginResponse, 0, sizeof(struct ns1__loginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__loginResponse(struct soap *soap, const struct ns1__loginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__loginResponse);
	if (soap_out_ns1__loginResponse(soap, tag?tag:"ns1:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__loginResponse * SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, struct ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_report_USCOREentry_USCORElist(struct soap *soap, struct report_USCOREentry_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_report_USCOREentry_USCORElist(struct soap *soap, struct report_USCOREentry_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_report_USCOREentry_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__entry_USCORElist2(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_report_USCOREentry_USCORElist(struct soap *soap, const char *tag, int id, const struct report_USCOREentry_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:entry_list2", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_report_USCOREentry_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__entry_USCORElist2(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct report_USCOREentry_USCORElist * SOAP_FMAC4 soap_in_report_USCOREentry_USCORElist(struct soap *soap, const char *tag, struct report_USCOREentry_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__entry_USCORElist2 **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct report_USCOREentry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_report_USCOREentry_USCORElist, sizeof(struct report_USCOREentry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_report_USCOREentry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__entry_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__entry_USCORElist2 *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__entry_USCORElist2(soap, NULL, a->__ptr + i, "ns1:entry_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__entry_USCORElist2 **)soap_push_block(soap, NULL, sizeof(struct ns1__entry_USCORElist2 *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__entry_USCORElist2(soap, NULL, p, "ns1:entry_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__entry_USCORElist2 **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct report_USCOREentry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_report_USCOREentry_USCORElist, 0, sizeof(struct report_USCOREentry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_report_USCOREentry_USCORElist(struct soap *soap, const struct report_USCOREentry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_report_USCOREentry_USCORElist);
	if (soap_out_report_USCOREentry_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct report_USCOREentry_USCORElist * SOAP_FMAC4 soap_get_report_USCOREentry_USCORElist(struct soap *soap, struct report_USCOREentry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_report_USCOREentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_report_USCOREfield_USCORElist(struct soap *soap, struct report_USCOREfield_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_report_USCOREfield_USCORElist(struct soap *soap, struct report_USCOREfield_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_report_USCOREfield_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__field_USCORElist2(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_report_USCOREfield_USCORElist(struct soap *soap, const char *tag, int id, const struct report_USCOREfield_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:field_list2", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_report_USCOREfield_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__field_USCORElist2(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct report_USCOREfield_USCORElist * SOAP_FMAC4 soap_in_report_USCOREfield_USCORElist(struct soap *soap, const char *tag, struct report_USCOREfield_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__field_USCORElist2 **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct report_USCOREfield_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_report_USCOREfield_USCORElist, sizeof(struct report_USCOREfield_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_report_USCOREfield_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__field_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__field_USCORElist2 *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__field_USCORElist2(soap, NULL, a->__ptr + i, "ns1:field_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__field_USCORElist2 **)soap_push_block(soap, NULL, sizeof(struct ns1__field_USCORElist2 *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__field_USCORElist2(soap, NULL, p, "ns1:field_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__field_USCORElist2 **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct report_USCOREfield_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_report_USCOREfield_USCORElist, 0, sizeof(struct report_USCOREfield_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_report_USCOREfield_USCORElist(struct soap *soap, const struct report_USCOREfield_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_report_USCOREfield_USCORElist);
	if (soap_out_report_USCOREfield_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct report_USCOREfield_USCORElist * SOAP_FMAC4 soap_get_report_USCOREfield_USCORElist(struct soap *soap, struct report_USCOREfield_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_report_USCOREfield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_last_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_last_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_last_USCOREviewed_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__last_USCOREviewed_USCOREentry(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_last_USCOREviewed_USCORElist(struct soap *soap, const char *tag, int id, const struct last_USCOREviewed_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:last_viewed_entry", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_last_USCOREviewed_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__last_USCOREviewed_USCOREentry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct last_USCOREviewed_USCORElist * SOAP_FMAC4 soap_in_last_USCOREviewed_USCORElist(struct soap *soap, const char *tag, struct last_USCOREviewed_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__last_USCOREviewed_USCOREentry **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct last_USCOREviewed_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_last_USCOREviewed_USCORElist, sizeof(struct last_USCOREviewed_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_last_USCOREviewed_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__last_USCOREviewed_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__last_USCOREviewed_USCOREentry *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__last_USCOREviewed_USCOREentry(soap, NULL, a->__ptr + i, "ns1:last_viewed_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__last_USCOREviewed_USCOREentry **)soap_push_block(soap, NULL, sizeof(struct ns1__last_USCOREviewed_USCOREentry *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__last_USCOREviewed_USCOREentry(soap, NULL, p, "ns1:last_viewed_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__last_USCOREviewed_USCOREentry **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct last_USCOREviewed_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_last_USCOREviewed_USCORElist, 0, sizeof(struct last_USCOREviewed_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_last_USCOREviewed_USCORElist(struct soap *soap, const struct last_USCOREviewed_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_last_USCOREviewed_USCORElist);
	if (soap_out_last_USCOREviewed_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct last_USCOREviewed_USCORElist * SOAP_FMAC4 soap_get_last_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_last_USCOREviewed_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_upcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_upcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_upcoming_USCOREactivities_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_upcoming_USCOREactivities_USCORElist(struct soap *soap, const char *tag, int id, const struct upcoming_USCOREactivities_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:upcoming_activity_entry", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_upcoming_USCOREactivities_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct upcoming_USCOREactivities_USCORElist * SOAP_FMAC4 soap_in_upcoming_USCOREactivities_USCORElist(struct soap *soap, const char *tag, struct upcoming_USCOREactivities_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__upcoming_USCOREactivity_USCOREentry **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct upcoming_USCOREactivities_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_upcoming_USCOREactivities_USCORElist, sizeof(struct upcoming_USCOREactivities_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_upcoming_USCOREactivities_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__upcoming_USCOREactivity_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, NULL, a->__ptr + i, "ns1:upcoming_activity_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__upcoming_USCOREactivity_USCOREentry **)soap_push_block(soap, NULL, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, NULL, p, "ns1:upcoming_activity_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__upcoming_USCOREactivity_USCOREentry **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct upcoming_USCOREactivities_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_upcoming_USCOREactivities_USCORElist, 0, sizeof(struct upcoming_USCOREactivities_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_upcoming_USCOREactivities_USCORElist(struct soap *soap, const struct upcoming_USCOREactivities_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_upcoming_USCOREactivities_USCORElist);
	if (soap_out_upcoming_USCOREactivities_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct upcoming_USCOREactivities_USCORElist * SOAP_FMAC4 soap_get_upcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_upcoming_USCOREactivities_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_module_USCOREnames(struct soap *soap, struct module_USCOREnames *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_module_USCOREnames(struct soap *soap, struct module_USCOREnames const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_module_USCOREnames))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_module_USCOREnames(struct soap *soap, const char *tag, int id, const struct module_USCOREnames *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_module_USCOREnames);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct module_USCOREnames * SOAP_FMAC4 soap_in_module_USCOREnames(struct soap *soap, const char *tag, struct module_USCOREnames *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct module_USCOREnames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_module_USCOREnames, sizeof(struct module_USCOREnames), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_module_USCOREnames(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct module_USCOREnames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_module_USCOREnames, 0, sizeof(struct module_USCOREnames), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_module_USCOREnames(struct soap *soap, const struct module_USCOREnames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_module_USCOREnames);
	if (soap_out_module_USCOREnames(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct module_USCOREnames * SOAP_FMAC4 soap_get_module_USCOREnames(struct soap *soap, struct module_USCOREnames *p, const char *tag, const char *type)
{
	if ((p = soap_in_module_USCOREnames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_md5_USCOREresults(struct soap *soap, struct md5_USCOREresults *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_md5_USCOREresults(struct soap *soap, struct md5_USCOREresults const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_md5_USCOREresults))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_md5_USCOREresults(struct soap *soap, const char *tag, int id, const struct md5_USCOREresults *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_md5_USCOREresults);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct md5_USCOREresults * SOAP_FMAC4 soap_in_md5_USCOREresults(struct soap *soap, const char *tag, struct md5_USCOREresults *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct md5_USCOREresults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_md5_USCOREresults, sizeof(struct md5_USCOREresults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_md5_USCOREresults(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct md5_USCOREresults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_md5_USCOREresults, 0, sizeof(struct md5_USCOREresults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_md5_USCOREresults(struct soap *soap, const struct md5_USCOREresults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_md5_USCOREresults);
	if (soap_out_md5_USCOREresults(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct md5_USCOREresults * SOAP_FMAC4 soap_get_md5_USCOREresults(struct soap *soap, struct md5_USCOREresults *p, const char *tag, const char *type)
{
	if ((p = soap_in_md5_USCOREresults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerToselect_USCOREfields(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, int id, const struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToselect_USCOREfields(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids * SOAP_FMAC4 soap_in_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *type)
{	int i, j;
	struct select_USCOREfields **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct new_USCOREset_USCORErelationhip_USCOREids *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_new_USCOREset_USCORErelationhip_USCOREids(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct select_USCOREfields **)soap_malloc(soap, sizeof(struct select_USCOREfields *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToselect_USCOREfields(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct select_USCOREfields **)soap_push_block(soap, NULL, sizeof(struct select_USCOREfields *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToselect_USCOREfields(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct select_USCOREfields **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct new_USCOREset_USCORErelationhip_USCOREids *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids, 0, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids);
	if (soap_out_new_USCOREset_USCORErelationhip_USCOREids(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids * SOAP_FMAC4 soap_get_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *p, const char *tag, const char *type)
{
	if ((p = soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, const struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:link_name_to_fields_array", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_in_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray, sizeof(struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, a->__ptr + i, "ns1:link_name_to_fields_array"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **)soap_push_block(soap, NULL, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, p, "ns1:link_name_to_fields_array"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray, 0, sizeof(struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_get_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_deleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_deleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_deleted_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_int);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_deleted_USCOREarray(struct soap *soap, const char *tag, int id, const struct deleted_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:int", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_deleted_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct deleted_USCOREarray * SOAP_FMAC4 soap_in_deleted_USCOREarray(struct soap *soap, const char *tag, struct deleted_USCOREarray *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct deleted_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deleted_USCOREarray, sizeof(struct deleted_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_deleted_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, NULL, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct deleted_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_deleted_USCOREarray, 0, sizeof(struct deleted_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_deleted_USCOREarray(struct soap *soap, const struct deleted_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_deleted_USCOREarray);
	if (soap_out_deleted_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct deleted_USCOREarray * SOAP_FMAC4 soap_get_deleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_deleted_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__modified_USCORErelationship_USCOREentry(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, const char *tag, int id, const struct modified_USCORErelationship_USCOREentry_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:modified_relationship_entry", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__modified_USCORErelationship_USCOREentry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct modified_USCORErelationship_USCOREentry_USCORElist * SOAP_FMAC4 soap_in_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, const char *tag, struct modified_USCORErelationship_USCOREentry_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__modified_USCORErelationship_USCOREentry **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct modified_USCORErelationship_USCOREentry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist, sizeof(struct modified_USCORErelationship_USCOREentry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_modified_USCORErelationship_USCOREentry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__modified_USCORErelationship_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__modified_USCORErelationship_USCOREentry *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(soap, NULL, a->__ptr + i, "ns1:modified_relationship_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__modified_USCORErelationship_USCOREentry **)soap_push_block(soap, NULL, sizeof(struct ns1__modified_USCORErelationship_USCOREentry *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(soap, NULL, p, "ns1:modified_relationship_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__modified_USCORErelationship_USCOREentry **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct modified_USCORErelationship_USCOREentry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist, 0, sizeof(struct modified_USCORErelationship_USCOREentry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, const struct modified_USCORErelationship_USCOREentry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist);
	if (soap_out_modified_USCORErelationship_USCOREentry_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct modified_USCORErelationship_USCOREentry_USCORElist * SOAP_FMAC4 soap_get_modified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_modified_USCORErelationship_USCOREentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	a->entry_USCORElist = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, const struct ns1__modified_USCORErelationship_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_serialize_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__modified_USCORErelationship_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREresult * SOAP_FMAC4 soap_in_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, const char *tag, struct ns1__modified_USCORErelationship_USCOREresult *a, const char *type)
{
	size_t soap_flag_result_USCOREcount = 1;
	size_t soap_flag_next_USCOREoffset = 1;
	size_t soap_flag_entry_USCORElist = 1;
	size_t soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__modified_USCORErelationship_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult, sizeof(struct ns1__modified_USCORErelationship_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__modified_USCORErelationship_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:modified_relationship_entry"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__modified_USCORErelationship_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult, 0, sizeof(struct ns1__modified_USCORErelationship_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, const struct ns1__modified_USCORErelationship_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult);
	if (soap_out_ns1__modified_USCORErelationship_USCOREresult(soap, tag?tag:"ns1:modified_relationship_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREresult * SOAP_FMAC4 soap_get_ns1__modified_USCORErelationship_USCOREresult(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modified_USCORErelationship_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, const struct ns1__modified_USCORErelationship_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__modified_USCORErelationship_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry * SOAP_FMAC4 soap_in_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, struct ns1__modified_USCORErelationship_USCOREentry *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__modified_USCORErelationship_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry, sizeof(struct ns1__modified_USCORErelationship_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__modified_USCORErelationship_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__modified_USCORErelationship_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry, 0, sizeof(struct ns1__modified_USCORErelationship_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_module_USCOREname > 0 || soap_flag_name_USCOREvalue_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, const struct ns1__modified_USCORErelationship_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry);
	if (soap_out_ns1__modified_USCORErelationship_USCOREentry(soap, tag?tag:"ns1:modified_relationship_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry * SOAP_FMAC4 soap_get_ns1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modified_USCORErelationship_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->number);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__error_USCOREvalue(struct soap *soap, const struct ns1__error_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->number);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__error_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__error_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__error_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "number", -1, &a->number, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue * SOAP_FMAC4 soap_in_ns1__error_USCOREvalue(struct soap *soap, const char *tag, struct ns1__error_USCOREvalue *a, const char *type)
{
	size_t soap_flag_number = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__error_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__error_USCOREvalue, sizeof(struct ns1__error_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__error_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "number", &a->number, "xsd:string"))
				{	soap_flag_number--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__error_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__error_USCOREvalue, 0, sizeof(struct ns1__error_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number > 0 || soap_flag_name > 0 || soap_flag_description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__error_USCOREvalue(struct soap *soap, const struct ns1__error_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__error_USCOREvalue);
	if (soap_out_ns1__error_USCOREvalue(soap, tag?tag:"ns1:error_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue * SOAP_FMAC4 soap_get_ns1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__error_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTolink_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, const struct search_USCORElink_USCOREarray_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTolink_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct search_USCORElink_USCOREarray_USCORElist * SOAP_FMAC4 soap_in_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct search_USCORElink_USCOREarray_USCORElist *a, const char *type)
{	int i, j;
	struct link_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct search_USCORElink_USCOREarray_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist, sizeof(struct search_USCORElink_USCOREarray_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_search_USCORElink_USCOREarray_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct link_USCOREvalue **)soap_malloc(soap, sizeof(struct link_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTolink_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct link_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct link_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTolink_USCOREvalue(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct link_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct search_USCORElink_USCOREarray_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist, 0, sizeof(struct search_USCORElink_USCOREarray_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, const struct search_USCORElink_USCOREarray_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist);
	if (soap_out_search_USCORElink_USCOREarray_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct search_USCORElink_USCOREarray_USCORElist * SOAP_FMAC4 soap_get_search_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_search_USCORElink_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	a->records = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__search_USCORElink_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, &a->records);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__search_USCORElink_USCOREname_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, "records", -1, &a->records, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue * SOAP_FMAC4 soap_in_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__search_USCORElink_USCOREname_USCOREvalue *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_records = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_records && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, "records", &a->records, "ns1:link_value"))
				{	soap_flag_records--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue, 0, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_records > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__search_USCORElink_USCOREname_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue);
	if (soap_out_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, tag?tag:"ns1:search_link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue * SOAP_FMAC4 soap_get_ns1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->entry_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__entry_USCORElist2(struct soap *soap, const struct ns1__entry_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entry_USCORElist2(struct soap *soap, const char *tag, int id, const struct ns1__entry_USCORElist2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entry_USCORElist2), type))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 * SOAP_FMAC4 soap_in_ns1__entry_USCORElist2(struct soap *soap, const char *tag, struct ns1__entry_USCORElist2 *a, const char *type)
{
	size_t soap_flag_entry_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__entry_USCORElist2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entry_USCORElist2, sizeof(struct ns1__entry_USCORElist2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__entry_USCORElist2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCORElist2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entry_USCORElist2, 0, sizeof(struct ns1__entry_USCORElist2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__entry_USCORElist2(struct soap *soap, const struct ns1__entry_USCORElist2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__entry_USCORElist2);
	if (soap_out_ns1__entry_USCORElist2(soap, tag?tag:"ns1:entry_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 * SOAP_FMAC4 soap_get_ns1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entry_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->field_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__field_USCORElist2(struct soap *soap, const struct ns1__field_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofield_USCORElist(soap, &a->field_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__field_USCORElist2(struct soap *soap, const char *tag, int id, const struct ns1__field_USCORElist2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__field_USCORElist2), type))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "field_list", -1, &a->field_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 * SOAP_FMAC4 soap_in_ns1__field_USCORElist2(struct soap *soap, const char *tag, struct ns1__field_USCORElist2 *a, const char *type)
{
	size_t soap_flag_field_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__field_USCORElist2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__field_USCORElist2, sizeof(struct ns1__field_USCORElist2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__field_USCORElist2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "field_list", &a->field_USCORElist, "ns1:field"))
				{	soap_flag_field_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__field_USCORElist2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__field_USCORElist2, 0, sizeof(struct ns1__field_USCORElist2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_field_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__field_USCORElist2(struct soap *soap, const struct ns1__field_USCORElist2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__field_USCORElist2);
	if (soap_out_ns1__field_USCORElist2(soap, tag?tag:"ns1:field_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 * SOAP_FMAC4 soap_get_ns1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__field_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREvalue))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__name_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREvalue(struct soap *soap, const char *tag, int id, const struct link_USCOREvalue *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREvalue);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__name_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREvalue * SOAP_FMAC4 soap_in_link_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue *a, const char *type)
{	int i, j;
	struct ns1__name_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREvalue, sizeof(struct link_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__name_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct ns1__name_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREvalue, 0, sizeof(struct link_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREvalue(struct soap *soap, const struct link_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREvalue);
	if (soap_out_link_USCOREvalue(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREvalue * SOAP_FMAC4 soap_get_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->link_USCOREvalue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREvalue2(struct soap *soap, const struct ns1__link_USCOREvalue2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolink_USCOREvalue(soap, &a->link_USCOREvalue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREvalue2(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREvalue2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREvalue2), type))
		return soap->error;
	if (soap_out_PointerTolink_USCOREvalue(soap, "link_value", -1, &a->link_USCOREvalue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 * SOAP_FMAC4 soap_in_ns1__link_USCOREvalue2(struct soap *soap, const char *tag, struct ns1__link_USCOREvalue2 *a, const char *type)
{
	size_t soap_flag_link_USCOREvalue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREvalue2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREvalue2, sizeof(struct ns1__link_USCOREvalue2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREvalue2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_link_USCOREvalue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREvalue(soap, "link_value", &a->link_USCOREvalue, "ns1:name_value"))
				{	soap_flag_link_USCOREvalue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREvalue2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREvalue2, 0, sizeof(struct ns1__link_USCOREvalue2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_link_USCOREvalue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREvalue2(struct soap *soap, const struct ns1__link_USCOREvalue2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREvalue2);
	if (soap_out_ns1__link_USCOREvalue2(soap, tag?tag:"ns1:link_value2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 * SOAP_FMAC4 soap_get_ns1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREvalue2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCORElist(struct soap *soap, struct link_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCORElist(struct soap *soap, struct link_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:link_name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCORElist * SOAP_FMAC4 soap_in_link_USCORElist(struct soap *soap, const char *tag, struct link_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREname_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCORElist, sizeof(struct link_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREname_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct ns1__link_USCOREname_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, p, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCORElist, 0, sizeof(struct link_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCORElist(struct soap *soap, const struct link_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCORElist);
	if (soap_out_link_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCORElist * SOAP_FMAC4 soap_get_link_USCORElist(struct soap *soap, struct link_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->link_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCORElist2(struct soap *soap, const struct ns1__link_USCORElist2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolink_USCORElist(soap, &a->link_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCORElist2(struct soap *soap, const char *tag, int id, const struct ns1__link_USCORElist2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCORElist2), type))
		return soap->error;
	if (soap_out_PointerTolink_USCORElist(soap, "link_list", -1, &a->link_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 * SOAP_FMAC4 soap_in_ns1__link_USCORElist2(struct soap *soap, const char *tag, struct ns1__link_USCORElist2 *a, const char *type)
{
	size_t soap_flag_link_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCORElist2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCORElist2, sizeof(struct ns1__link_USCORElist2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCORElist2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_link_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElist(soap, "link_list", &a->link_USCORElist, "ns1:link_name_value"))
				{	soap_flag_link_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCORElist2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCORElist2, 0, sizeof(struct ns1__link_USCORElist2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_link_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCORElist2(struct soap *soap, const struct ns1__link_USCORElist2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCORElist2);
	if (soap_out_ns1__link_USCORElist2(soap, tag?tag:"ns1:link_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 * SOAP_FMAC4 soap_get_ns1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->action);
	soap_default_string(soap, &a->access);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__acl_USCORElist_USCOREentry(struct soap *soap, const struct ns1__acl_USCORElist_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->action);
	soap_serialize_string(soap, &a->access);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__acl_USCORElist_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "action", -1, &a->action, ""))
		return soap->error;
	if (soap_out_string(soap, "access", -1, &a->access, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry * SOAP_FMAC4 soap_in_ns1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__acl_USCORElist_USCOREentry *a, const char *type)
{
	size_t soap_flag_action = 1;
	size_t soap_flag_access = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__acl_USCORElist_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry, sizeof(struct ns1__acl_USCORElist_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__acl_USCORElist_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "action", &a->action, "xsd:string"))
				{	soap_flag_action--;
					continue;
				}
			if (soap_flag_access && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "access", &a->access, "xsd:string"))
				{	soap_flag_access--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__acl_USCORElist_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry, 0, sizeof(struct ns1__acl_USCORElist_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_action > 0 || soap_flag_access > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__acl_USCORElist_USCOREentry(struct soap *soap, const struct ns1__acl_USCORElist_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry);
	if (soap_out_ns1__acl_USCORElist_USCOREentry(soap, tag?tag:"ns1:acl_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry * SOAP_FMAC4 soap_get_ns1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__acl_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acl_USCORElist(struct soap *soap, struct acl_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acl_USCORElist(struct soap *soap, struct acl_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_acl_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__acl_USCORElist_USCOREentry(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acl_USCORElist(struct soap *soap, const char *tag, int id, const struct acl_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:acl_list_entry", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_acl_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__acl_USCORElist_USCOREentry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acl_USCORElist * SOAP_FMAC4 soap_in_acl_USCORElist(struct soap *soap, const char *tag, struct acl_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__acl_USCORElist_USCOREentry **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct acl_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acl_USCORElist, sizeof(struct acl_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acl_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__acl_USCORElist_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__acl_USCORElist_USCOREentry *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__acl_USCORElist_USCOREentry(soap, NULL, a->__ptr + i, "ns1:acl_list_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__acl_USCORElist_USCOREentry **)soap_push_block(soap, NULL, sizeof(struct ns1__acl_USCORElist_USCOREentry *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__acl_USCORElist_USCOREentry(soap, NULL, p, "ns1:acl_list_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__acl_USCORElist_USCOREentry **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acl_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acl_USCORElist, 0, sizeof(struct acl_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acl_USCORElist(struct soap *soap, const struct acl_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_acl_USCORElist);
	if (soap_out_acl_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct acl_USCORElist * SOAP_FMAC4 soap_get_acl_USCORElist(struct soap *soap, struct acl_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_acl_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->module_USCOREkey);
	soap_default_string(soap, &a->module_USCORElabel);
	soap_default_xsd__boolean(soap, &a->favorite_USCOREenabled);
	a->acls = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__module_USCORElist_USCOREentry(struct soap *soap, const struct ns1__module_USCORElist_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->module_USCOREkey);
	soap_serialize_string(soap, &a->module_USCORElabel);
	soap_serialize_PointerToacl_USCORElist(soap, &a->acls);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__module_USCORElist_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__module_USCORElist_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "module_key", -1, &a->module_USCOREkey, ""))
		return soap->error;
	if (soap_out_string(soap, "module_label", -1, &a->module_USCORElabel, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "favorite_enabled", -1, &a->favorite_USCOREenabled, ""))
		return soap->error;
	if (soap_out_PointerToacl_USCORElist(soap, "acls", -1, &a->acls, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry * SOAP_FMAC4 soap_in_ns1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__module_USCORElist_USCOREentry *a, const char *type)
{
	size_t soap_flag_module_USCOREkey = 1;
	size_t soap_flag_module_USCORElabel = 1;
	size_t soap_flag_favorite_USCOREenabled = 1;
	size_t soap_flag_acls = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__module_USCORElist_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__module_USCORElist_USCOREentry, sizeof(struct ns1__module_USCORElist_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__module_USCORElist_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_module_USCOREkey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_key", &a->module_USCOREkey, "xsd:string"))
				{	soap_flag_module_USCOREkey--;
					continue;
				}
			if (soap_flag_module_USCORElabel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_label", &a->module_USCORElabel, "xsd:string"))
				{	soap_flag_module_USCORElabel--;
					continue;
				}
			if (soap_flag_favorite_USCOREenabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "favorite_enabled", &a->favorite_USCOREenabled, "xsd:boolean"))
				{	soap_flag_favorite_USCOREenabled--;
					continue;
				}
			if (soap_flag_acls && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToacl_USCORElist(soap, "acls", &a->acls, "ns1:acl_list_entry"))
				{	soap_flag_acls--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__module_USCORElist_USCOREentry, 0, sizeof(struct ns1__module_USCORElist_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_module_USCOREkey > 0 || soap_flag_module_USCORElabel > 0 || soap_flag_favorite_USCOREenabled > 0 || soap_flag_acls > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__module_USCORElist_USCOREentry(struct soap *soap, const struct ns1__module_USCORElist_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__module_USCORElist_USCOREentry);
	if (soap_out_ns1__module_USCORElist_USCOREentry(soap, tag?tag:"ns1:module_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry * SOAP_FMAC4 soap_get_ns1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__module_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->item_USCOREid);
	soap_default_string(soap, &a->item_USCOREsummary);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->monitor_USCOREid);
	soap_default_string(soap, &a->date_USCOREmodified);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, const struct ns1__last_USCOREviewed_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->item_USCOREid);
	soap_serialize_string(soap, &a->item_USCOREsummary);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->monitor_USCOREid);
	soap_serialize_string(soap, &a->date_USCOREmodified);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__last_USCOREviewed_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "item_id", -1, &a->item_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "item_summary", -1, &a->item_USCOREsummary, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "monitor_id", -1, &a->monitor_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "date_modified", -1, &a->date_USCOREmodified, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry * SOAP_FMAC4 soap_in_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, struct ns1__last_USCOREviewed_USCOREentry *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_item_USCOREid = 1;
	size_t soap_flag_item_USCOREsummary = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_monitor_USCOREid = 1;
	size_t soap_flag_date_USCOREmodified = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__last_USCOREviewed_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry, sizeof(struct ns1__last_USCOREviewed_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__last_USCOREviewed_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_item_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "item_id", &a->item_USCOREid, "xsd:string"))
				{	soap_flag_item_USCOREid--;
					continue;
				}
			if (soap_flag_item_USCOREsummary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "item_summary", &a->item_USCOREsummary, "xsd:string"))
				{	soap_flag_item_USCOREsummary--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_monitor_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "monitor_id", &a->monitor_USCOREid, "xsd:string"))
				{	soap_flag_monitor_USCOREid--;
					continue;
				}
			if (soap_flag_date_USCOREmodified && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "date_modified", &a->date_USCOREmodified, "xsd:string"))
				{	soap_flag_date_USCOREmodified--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__last_USCOREviewed_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry, 0, sizeof(struct ns1__last_USCOREviewed_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_item_USCOREid > 0 || soap_flag_item_USCOREsummary > 0 || soap_flag_module_USCOREname > 0 || soap_flag_monitor_USCOREid > 0 || soap_flag_date_USCOREmodified > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, const struct ns1__last_USCOREviewed_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry);
	if (soap_out_ns1__last_USCOREviewed_USCOREentry(soap, tag?tag:"ns1:last_viewed_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry * SOAP_FMAC4 soap_get_ns1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__last_USCOREviewed_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->module);
	soap_default_string(soap, &a->date_USCOREdue);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const struct ns1__upcoming_USCOREactivity_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->module);
	soap_serialize_string(soap, &a->date_USCOREdue);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__upcoming_USCOREactivity_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "module", -1, &a->module, ""))
		return soap->error;
	if (soap_out_string(soap, "date_due", -1, &a->date_USCOREdue, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry * SOAP_FMAC4 soap_in_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, struct ns1__upcoming_USCOREactivity_USCOREentry *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_module = 1;
	size_t soap_flag_date_USCOREdue = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__upcoming_USCOREactivity_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__upcoming_USCOREactivity_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_module && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module", &a->module, "xsd:string"))
				{	soap_flag_module--;
					continue;
				}
			if (soap_flag_date_USCOREdue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "date_due", &a->date_USCOREdue, "xsd:string"))
				{	soap_flag_date_USCOREdue--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__upcoming_USCOREactivity_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry, 0, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_module > 0 || soap_flag_date_USCOREdue > 0 || soap_flag_summary > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const struct ns1__upcoming_USCOREactivity_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry);
	if (soap_out_ns1__upcoming_USCOREactivity_USCOREentry(soap, tag?tag:"ns1:upcoming_activity_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry * SOAP_FMAC4 soap_get_ns1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__upcoming_USCOREactivity_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *type)
{
	size_t soap_flag_result_USCOREcount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, 0, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult);
	if (soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag?tag:"ns1:get_entries_count_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_module_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_module_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_module_USCORElist_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__module_USCORElist_USCOREentry(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_module_USCORElist_USCOREarray(struct soap *soap, const char *tag, int id, const struct module_USCORElist_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:module_list_entry", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_module_USCORElist_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__module_USCORElist_USCOREentry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct module_USCORElist_USCOREarray * SOAP_FMAC4 soap_in_module_USCORElist_USCOREarray(struct soap *soap, const char *tag, struct module_USCORElist_USCOREarray *a, const char *type)
{	int i, j;
	struct ns1__module_USCORElist_USCOREentry **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct module_USCORElist_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_module_USCORElist_USCOREarray, sizeof(struct module_USCORElist_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_module_USCORElist_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__module_USCORElist_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__module_USCORElist_USCOREentry *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__module_USCORElist_USCOREentry(soap, NULL, a->__ptr + i, "ns1:module_list_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__module_USCORElist_USCOREentry **)soap_push_block(soap, NULL, sizeof(struct ns1__module_USCORElist_USCOREentry *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__module_USCORElist_USCOREentry(soap, NULL, p, "ns1:module_list_entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__module_USCORElist_USCOREentry **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct module_USCORElist_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_module_USCORElist_USCOREarray, 0, sizeof(struct module_USCORElist_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_module_USCORElist_USCOREarray(struct soap *soap, const struct module_USCORElist_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_module_USCORElist_USCOREarray);
	if (soap_out_module_USCORElist_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct module_USCORElist_USCOREarray * SOAP_FMAC4 soap_get_module_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_module_USCORElist_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->modules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__module_USCORElist(struct soap *soap, const struct ns1__module_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTomodule_USCORElist_USCOREarray(soap, &a->modules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__module_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__module_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__module_USCORElist), type))
		return soap->error;
	if (soap_out_PointerTomodule_USCORElist_USCOREarray(soap, "modules", -1, &a->modules, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__module_USCORElist * SOAP_FMAC4 soap_in_ns1__module_USCORElist(struct soap *soap, const char *tag, struct ns1__module_USCORElist *a, const char *type)
{
	size_t soap_flag_modules = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__module_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__module_USCORElist, sizeof(struct ns1__module_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__module_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomodule_USCORElist_USCOREarray(soap, "modules", &a->modules, "ns1:module_list_entry"))
				{	soap_flag_modules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__module_USCORElist, 0, sizeof(struct ns1__module_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modules > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__module_USCORElist(struct soap *soap, const struct ns1__module_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__module_USCORElist);
	if (soap_out_ns1__module_USCORElist(soap, tag?tag:"ns1:module_list", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__module_USCORElist * SOAP_FMAC4 soap_get_ns1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__module_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->document_USCORErevision = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__document_USCORErevision(soap, &a->document_USCORErevision);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_PointerTons1__document_USCORErevision(soap, "document_revision", -1, &a->document_USCORErevision, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *type)
{
	size_t soap_flag_document_USCORErevision = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_document_USCORErevision && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__document_USCORErevision(soap, "document_revision", &a->document_USCORErevision, "ns1:document_revision"))
				{	soap_flag_document_USCORErevision--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_document_USCORErevision > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision);
	if (soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag?tag:"ns1:new_return_document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->document_USCOREname);
	soap_default_string(soap, &a->revision);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->file);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__document_USCORErevision(struct soap *soap, const struct ns1__document_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->document_USCOREname);
	soap_serialize_string(soap, &a->revision);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->file);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__document_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__document_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__document_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "document_name", -1, &a->document_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "revision", -1, &a->revision, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "file", -1, &a->file, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__document_USCORErevision * SOAP_FMAC4 soap_in_ns1__document_USCORErevision(struct soap *soap, const char *tag, struct ns1__document_USCORErevision *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_document_USCOREname = 1;
	size_t soap_flag_revision = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_file = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__document_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__document_USCORErevision, sizeof(struct ns1__document_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__document_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_document_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "document_name", &a->document_USCOREname, "xsd:string"))
				{	soap_flag_document_USCOREname--;
					continue;
				}
			if (soap_flag_revision && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "revision", &a->revision, "xsd:string"))
				{	soap_flag_revision--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__document_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__document_USCORErevision, 0, sizeof(struct ns1__document_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_document_USCOREname > 0 || soap_flag_revision > 0 || soap_flag_filename > 0 || soap_flag_file > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__document_USCORErevision(struct soap *soap, const struct ns1__document_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__document_USCORErevision);
	if (soap_out_ns1__document_USCORErevision(soap, tag?tag:"ns1:document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__document_USCORErevision * SOAP_FMAC4 soap_get_ns1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__document_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->created);
	soap_default_int(soap, &a->failed);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->created, SOAP_TYPE_int);
	soap_embedded(soap, &a->failed, SOAP_TYPE_int);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "created", -1, &a->created, ""))
		return soap->error;
	if (soap_out_int(soap, "failed", -1, &a->failed, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	size_t soap_flag_created = 1;
	size_t soap_flag_failed = 1;
	size_t soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "created", &a->created, "xsd:int"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_failed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "failed", &a->failed, "xsd:int"))
				{	soap_flag_failed--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_created > 0 || soap_flag_failed > 0 || soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag?tag:"ns1:new_set_relationship_list_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *type)
{
	size_t soap_flag_ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ids > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag?tag:"ns1:new_set_entries_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag?tag:"ns1:new_set_entry_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->flavor);
	soap_default_string(soap, &a->version);
	soap_default_string(soap, &a->gmt_USCOREtime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->flavor);
	soap_serialize_string(soap, &a->version);
	soap_serialize_string(soap, &a->gmt_USCOREtime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "flavor", -1, &a->flavor, ""))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, ""))
		return soap->error;
	if (soap_out_string(soap, "gmt_time", -1, &a->gmt_USCOREtime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *type)
{
	size_t soap_flag_flavor = 1;
	size_t soap_flag_version = 1;
	size_t soap_flag_gmt_USCOREtime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_flavor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "flavor", &a->flavor, "xsd:string"))
				{	soap_flag_flavor--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_gmt_USCOREtime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "gmt_time", &a->gmt_USCOREtime, "xsd:string"))
				{	soap_flag_gmt_USCOREtime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult, 0, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_flavor > 0 || soap_flag_version > 0 || soap_flag_gmt_USCOREtime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult);
	if (soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag?tag:"ns1:get_server_info_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->total_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	a->entry_USCORElist = NULL;
	a->relationship_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->total_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTolink_USCORElists(soap, &a->relationship_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "total_count", -1, &a->total_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCORElists(soap, "relationship_list", -1, &a->relationship_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *type)
{
	size_t soap_flag_result_USCOREcount = 1;
	size_t soap_flag_total_USCOREcount = 1;
	size_t soap_flag_next_USCOREoffset = 1;
	size_t soap_flag_entry_USCORElist = 1;
	size_t soap_flag_relationship_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_total_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "total_count", &a->total_USCOREcount, "xsd:int"))
				{	soap_flag_total_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_relationship_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElists(soap, "relationship_list", &a->relationship_USCORElist, "ns1:link_list2"))
				{	soap_flag_relationship_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2, 0, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_total_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_relationship_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2);
	if (soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag?tag:"ns1:get_entry_list_result_version2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_search_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_search_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_search_USCORElink_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_search_USCORElink_USCORElist(struct soap *soap, const char *tag, int id, const struct search_USCORElink_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:search_link_name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_search_USCORElink_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct search_USCORElink_USCORElist * SOAP_FMAC4 soap_in_search_USCORElink_USCORElist(struct soap *soap, const char *tag, struct search_USCORElink_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__search_USCORElink_USCOREname_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct search_USCORElink_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_search_USCORElink_USCORElist, sizeof(struct search_USCORElink_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_search_USCORElink_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__search_USCORElink_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:search_link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__search_USCORElink_USCOREname_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, NULL, p, "ns1:search_link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__search_USCORElink_USCOREname_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct search_USCORElink_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_search_USCORElink_USCORElist, 0, sizeof(struct search_USCORElink_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_search_USCORElink_USCORElist(struct soap *soap, const struct search_USCORElink_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_search_USCORElink_USCORElist);
	if (soap_out_search_USCORElink_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct search_USCORElink_USCORElist * SOAP_FMAC4 soap_get_search_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_search_USCORElink_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->entry_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const struct ns1__return_USCOREsearch_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTosearch_USCORElink_USCORElist(soap, &a->entry_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__return_USCOREsearch_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerTosearch_USCORElink_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult * SOAP_FMAC4 soap_in_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, struct ns1__return_USCOREsearch_USCOREresult *a, const char *type)
{
	size_t soap_flag_entry_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__return_USCOREsearch_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult, sizeof(struct ns1__return_USCOREsearch_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__return_USCOREsearch_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosearch_USCORElink_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:search_link_name_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREsearch_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult, 0, sizeof(struct ns1__return_USCOREsearch_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const struct ns1__return_USCOREsearch_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult);
	if (soap_out_ns1__return_USCOREsearch_USCOREresult(soap, tag?tag:"ns1:return_search_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult * SOAP_FMAC4 soap_get_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__return_USCOREsearch_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCORElists(struct soap *soap, struct link_USCORElists *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCORElists(struct soap *soap, struct link_USCORElists const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCORElists))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCORElist2(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCORElists(struct soap *soap, const char *tag, int id, const struct link_USCORElists *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:link_list2", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCORElists);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCORElist2(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCORElists * SOAP_FMAC4 soap_in_link_USCORElists(struct soap *soap, const char *tag, struct link_USCORElists *a, const char *type)
{	int i, j;
	struct ns1__link_USCORElist2 **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCORElists *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCORElists, sizeof(struct link_USCORElists), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCORElists(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__link_USCORElist2 *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCORElist2(soap, NULL, a->__ptr + i, "ns1:link_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCORElist2 **)soap_push_block(soap, NULL, sizeof(struct ns1__link_USCORElist2 *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCORElist2(soap, NULL, p, "ns1:link_list2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__link_USCORElist2 **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCORElists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCORElists, 0, sizeof(struct link_USCORElists), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCORElists(struct soap *soap, const struct link_USCORElists *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCORElists);
	if (soap_out_link_USCORElists(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCORElists * SOAP_FMAC4 soap_get_link_USCORElists(struct soap *soap, struct link_USCORElists *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_entry_USCORElist(struct soap *soap, struct entry_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_entry_USCORElist(struct soap *soap, struct entry_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_entry_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__entry_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_entry_USCORElist(struct soap *soap, const char *tag, int id, const struct entry_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:entry_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_entry_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__entry_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct entry_USCORElist * SOAP_FMAC4 soap_in_entry_USCORElist(struct soap *soap, const char *tag, struct entry_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__entry_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct entry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_entry_USCORElist, sizeof(struct entry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_entry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:entry_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__entry_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct ns1__entry_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, p, "ns1:entry_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct entry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_entry_USCORElist, 0, sizeof(struct entry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_entry_USCORElist(struct soap *soap, const struct entry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_entry_USCORElist);
	if (soap_out_entry_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct entry_USCORElist * SOAP_FMAC4 soap_get_entry_USCORElist(struct soap *soap, struct entry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_entry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->entry_USCORElist = NULL;
	a->relationship_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTolink_USCORElists(soap, &a->relationship_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2), type))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCORElists(soap, "relationship_list", -1, &a->relationship_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *type)
{
	size_t soap_flag_entry_USCORElist = 1;
	size_t soap_flag_relationship_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_relationship_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElists(soap, "relationship_list", &a->relationship_USCORElist, "ns1:link_list2"))
				{	soap_flag_relationship_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2, 0, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCORElist > 0 || soap_flag_relationship_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2);
	if (soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag?tag:"ns1:get_entry_result_version2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREarray_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREvalue2(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCOREarray_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:link_value2", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREvalue2(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist * SOAP_FMAC4 soap_in_link_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct link_USCOREarray_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREvalue2 **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREarray_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREarray_USCORElist, sizeof(struct link_USCOREarray_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREarray_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREvalue2 **)soap_malloc(soap, sizeof(struct ns1__link_USCOREvalue2 *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREvalue2(soap, NULL, a->__ptr + i, "ns1:link_value2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREvalue2 **)soap_push_block(soap, NULL, sizeof(struct ns1__link_USCOREvalue2 *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREvalue2(soap, NULL, p, "ns1:link_value2"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__link_USCOREvalue2 **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREarray_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREarray_USCORElist, 0, sizeof(struct link_USCOREarray_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREarray_USCORElist(struct soap *soap, const struct link_USCOREarray_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (soap_out_link_USCOREarray_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist * SOAP_FMAC4 soap_get_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	a->records = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__link_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerTolink_USCOREarray_USCORElist(soap, &a->records);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREname_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREarray_USCORElist(soap, "records", -1, &a->records, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue * SOAP_FMAC4 soap_in_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_records = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREname_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREname_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_records && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREarray_USCORElist(soap, "records", &a->records, "ns1:link_value2"))
				{	soap_flag_records--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, 0, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_records > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__link_USCOREname_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue);
	if (soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag?tag:"ns1:link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue * SOAP_FMAC4 soap_get_ns1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_select_USCOREfields(struct soap *soap, struct select_USCOREfields *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_select_USCOREfields(struct soap *soap, struct select_USCOREfields const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_select_USCOREfields))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_select_USCOREfields(struct soap *soap, const char *tag, int id, const struct select_USCOREfields *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_select_USCOREfields);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct select_USCOREfields * SOAP_FMAC4 soap_in_select_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct select_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_select_USCOREfields, sizeof(struct select_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_select_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_select_USCOREfields, 0, sizeof(struct select_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_select_USCOREfields(struct soap *soap, const struct select_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_select_USCOREfields);
	if (soap_out_select_USCOREfields(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct select_USCOREfields * SOAP_FMAC4 soap_get_select_USCOREfields(struct soap *soap, struct select_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_select_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	a->value = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, 0, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag?tag:"ns1:link_name_to_fields_array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_get_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_name_USCOREvalue_USCORElists))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_name_USCOREvalue_USCORElists(struct soap *soap, const char *tag, int id, const struct name_USCOREvalue_USCORElists *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToname_USCOREvalue_USCORElist(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists * SOAP_FMAC4 soap_in_name_USCOREvalue_USCORElists(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElists *a, const char *type)
{	int i, j;
	struct name_USCOREvalue_USCORElist **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct name_USCOREvalue_USCORElists *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_name_USCOREvalue_USCORElists, sizeof(struct name_USCOREvalue_USCORElists), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_name_USCOREvalue_USCORElists(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct name_USCOREvalue_USCORElist **)soap_push_block(soap, NULL, sizeof(struct name_USCOREvalue_USCORElist *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_name_USCOREvalue_USCORElists, 0, sizeof(struct name_USCOREvalue_USCORElists), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_name_USCOREvalue_USCORElists(struct soap *soap, const struct name_USCOREvalue_USCORElists *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (soap_out_name_USCOREvalue_USCORElists(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists * SOAP_FMAC4 soap_get_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *p, const char *tag, const char *type)
{
	if ((p = soap_in_name_USCOREvalue_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name_USCOREvalue_USCORElists = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult * SOAP_FMAC4 soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *type)
{
	size_t soap_flag_name_USCOREvalue_USCORElists = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult, 0, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name_USCOREvalue_USCORElists > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult);
	if (soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag?tag:"ns1:set_entries_detail_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult * SOAP_FMAC4 soap_get_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__entry_USCOREvalue(struct soap *soap, const struct ns1__entry_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__entry_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entry_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue * SOAP_FMAC4 soap_in_ns1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__entry_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__entry_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entry_USCOREvalue, 0, sizeof(struct ns1__entry_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_module_USCOREname > 0 || soap_flag_name_USCOREvalue_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__entry_USCOREvalue(struct soap *soap, const struct ns1__entry_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__entry_USCOREvalue);
	if (soap_out_ns1__entry_USCOREvalue(soap, tag?tag:"ns1:entry_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue * SOAP_FMAC4 soap_get_ns1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREfield_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREfield(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREfield_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCOREfield_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:link_field", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREfield(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist * SOAP_FMAC4 soap_in_link_USCOREfield_USCORElist(struct soap *soap, const char *tag, struct link_USCOREfield_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREfield **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREfield_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREfield_USCORElist, sizeof(struct link_USCOREfield_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREfield_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREfield **)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREfield(soap, NULL, a->__ptr + i, "ns1:link_field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREfield **)soap_push_block(soap, NULL, sizeof(struct ns1__link_USCOREfield *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREfield(soap, NULL, p, "ns1:link_field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__link_USCOREfield **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREfield_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREfield_USCORElist, 0, sizeof(struct link_USCOREfield_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREfield_USCORElist(struct soap *soap, const struct link_USCOREfield_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (soap_out_link_USCOREfield_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist * SOAP_FMAC4 soap_get_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREfield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_field_USCORElist(struct soap *soap, struct field_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_field_USCORElist(struct soap *soap, struct field_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_field_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__field(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_field_USCORElist(struct soap *soap, const char *tag, int id, const struct field_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:field", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_field_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__field(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct field_USCORElist * SOAP_FMAC4 soap_in_field_USCORElist(struct soap *soap, const char *tag, struct field_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__field **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct field_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_field_USCORElist, sizeof(struct field_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_field_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__field **)soap_malloc(soap, sizeof(struct ns1__field *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__field(soap, NULL, a->__ptr + i, "ns1:field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__field **)soap_push_block(soap, NULL, sizeof(struct ns1__field *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__field(soap, NULL, p, "ns1:field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__field **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct field_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_field_USCORElist, 0, sizeof(struct field_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_field_USCORElist(struct soap *soap, const struct field_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_field_USCORElist);
	if (soap_out_field_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct field_USCORElist * SOAP_FMAC4 soap_get_field_USCORElist(struct soap *soap, struct field_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_field_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->table_USCOREname);
	a->module_USCOREfields = NULL;
	a->link_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__new_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->table_USCOREname);
	soap_serialize_PointerTofield_USCORElist(soap, &a->module_USCOREfields);
	soap_serialize_PointerTolink_USCOREfield_USCORElist(soap, &a->link_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREmodule_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "table_name", -1, &a->table_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "module_fields", -1, &a->module_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREfield_USCORElist(soap, "link_fields", -1, &a->link_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_in_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, struct ns1__new_USCOREmodule_USCOREfields *a, const char *type)
{
	size_t soap_flag_module_USCOREname = 1;
	size_t soap_flag_table_USCOREname = 1;
	size_t soap_flag_module_USCOREfields = 1;
	size_t soap_flag_link_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREmodule_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields, sizeof(struct ns1__new_USCOREmodule_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREmodule_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_table_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "table_name", &a->table_USCOREname, "xsd:string"))
				{	soap_flag_table_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "module_fields", &a->module_USCOREfields, "ns1:field"))
				{	soap_flag_module_USCOREfields--;
					continue;
				}
			if (soap_flag_link_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREfield_USCORElist(soap, "link_fields", &a->link_USCOREfields, "ns1:link_field"))
				{	soap_flag_link_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREmodule_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields, 0, sizeof(struct ns1__new_USCOREmodule_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_module_USCOREname > 0 || soap_flag_table_USCOREname > 0 || soap_flag_module_USCOREfields > 0 || soap_flag_link_USCOREfields > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__new_USCOREmodule_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields);
	if (soap_out_ns1__new_USCOREmodule_USCOREfields(soap, tag?tag:"ns1:new_module_fields", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_get_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREmodule_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__name_USCOREvalue(struct soap *soap, const struct ns1__name_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__name_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__name_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__name_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue * SOAP_FMAC4 soap_in_ns1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__name_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__name_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__name_USCOREvalue, 0, sizeof(struct ns1__name_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__name_USCOREvalue(struct soap *soap, const struct ns1__name_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__name_USCOREvalue);
	if (soap_out_ns1__name_USCOREvalue(soap, tag?tag:"ns1:name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue * SOAP_FMAC4 soap_get_ns1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->type);
	soap_default_string(soap, &a->relationship);
	soap_default_string(soap, &a->module);
	soap_default_string(soap, &a->bean_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREfield(struct soap *soap, const struct ns1__link_USCOREfield *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->relationship);
	soap_serialize_string(soap, &a->module);
	soap_serialize_string(soap, &a->bean_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREfield(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREfield *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREfield), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "relationship", -1, &a->relationship, ""))
		return soap->error;
	if (soap_out_string(soap, "module", -1, &a->module, ""))
		return soap->error;
	if (soap_out_string(soap, "bean_name", -1, &a->bean_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREfield * SOAP_FMAC4 soap_in_ns1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_relationship = 1;
	size_t soap_flag_module = 1;
	size_t soap_flag_bean_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREfield *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREfield(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_relationship && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "relationship", &a->relationship, "xsd:string"))
				{	soap_flag_relationship--;
					continue;
				}
			if (soap_flag_module && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module", &a->module, "xsd:string"))
				{	soap_flag_module--;
					continue;
				}
			if (soap_flag_bean_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bean_name", &a->bean_USCOREname, "xsd:string"))
				{	soap_flag_bean_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREfield, 0, sizeof(struct ns1__link_USCOREfield), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_type > 0 || soap_flag_relationship > 0 || soap_flag_module > 0 || soap_flag_bean_USCOREname > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREfield(struct soap *soap, const struct ns1__link_USCOREfield *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREfield);
	if (soap_out_ns1__link_USCOREfield(soap, tag?tag:"ns1:link_field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREfield * SOAP_FMAC4 soap_get_ns1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_name_USCOREvalue_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__name_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_name_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, const struct name_USCOREvalue_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:name_value", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__name_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist * SOAP_FMAC4 soap_in_name_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__name_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct name_USCOREvalue_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_name_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_name_USCOREvalue_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__name_USCOREvalue **)soap_push_block(soap, NULL, sizeof(struct ns1__name_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_name_USCOREvalue_USCORElist, 0, sizeof(struct name_USCOREvalue_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_name_USCOREvalue_USCORElist(struct soap *soap, const struct name_USCOREvalue_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (soap_out_name_USCOREvalue_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist * SOAP_FMAC4 soap_get_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_name_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__field(struct soap *soap, struct ns1__field *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->type);
	soap_default_string(soap, &a->group);
	soap_default_string(soap, &a->label);
	soap_default_int(soap, &a->required);
	a->options = NULL;
	soap_default_string(soap, &a->default_USCOREvalue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__field(struct soap *soap, const struct ns1__field *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->group);
	soap_serialize_string(soap, &a->label);
	soap_embedded(soap, &a->required, SOAP_TYPE_int);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->options);
	soap_serialize_string(soap, &a->default_USCOREvalue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__field(struct soap *soap, const char *tag, int id, const struct ns1__field *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__field), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "group", -1, &a->group, ""))
		return soap->error;
	if (soap_out_string(soap, "label", -1, &a->label, ""))
		return soap->error;
	if (soap_out_int(soap, "required", -1, &a->required, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "options", -1, &a->options, ""))
		return soap->error;
	if (soap_out_string(soap, "default_value", -1, &a->default_USCOREvalue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__field * SOAP_FMAC4 soap_in_ns1__field(struct soap *soap, const char *tag, struct ns1__field *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_group = 1;
	size_t soap_flag_label = 1;
	size_t soap_flag_required = 1;
	size_t soap_flag_options = 1;
	size_t soap_flag_default_USCOREvalue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__field *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__field, sizeof(struct ns1__field), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__field(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_group && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "group", &a->group, "xsd:string"))
				{	soap_flag_group--;
					continue;
				}
			if (soap_flag_label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "label", &a->label, "xsd:string"))
				{	soap_flag_label--;
					continue;
				}
			if (soap_flag_required && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "required", &a->required, "xsd:int"))
				{	soap_flag_required--;
					continue;
				}
			if (soap_flag_options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "options", &a->options, "ns1:link_value"))
				{	soap_flag_options--;
					continue;
				}
			if (soap_flag_default_USCOREvalue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "default_value", &a->default_USCOREvalue, "xsd:string"))
				{	soap_flag_default_USCOREvalue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__field *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__field, 0, sizeof(struct ns1__field), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_type > 0 || soap_flag_group > 0 || soap_flag_label > 0 || soap_flag_required > 0 || soap_flag_options > 0 || soap_flag_default_USCOREvalue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__field(struct soap *soap, const struct ns1__field *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__field);
	if (soap_out_ns1__field(soap, tag?tag:"ns1:field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field * SOAP_FMAC4 soap_get_ns1__field(struct soap *soap, struct ns1__field *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__user_USCOREauth(struct soap *soap, const struct ns1__user_USCOREauth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user_USCOREauth(struct soap *soap, const char *tag, int id, const struct ns1__user_USCOREauth *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user_USCOREauth), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__user_USCOREauth * SOAP_FMAC4 soap_in_ns1__user_USCOREauth(struct soap *soap, const char *tag, struct ns1__user_USCOREauth *a, const char *type)
{
	size_t soap_flag_user_USCOREname = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__user_USCOREauth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user_USCOREauth, sizeof(struct ns1__user_USCOREauth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__user_USCOREauth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREauth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user_USCOREauth, 0, sizeof(struct ns1__user_USCOREauth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_user_USCOREname > 0 || soap_flag_password > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__user_USCOREauth(struct soap *soap, const struct ns1__user_USCOREauth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__user_USCOREauth);
	if (soap_out_ns1__user_USCOREauth(soap, tag?tag:"ns1:user_auth", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__user_USCOREauth * SOAP_FMAC4 soap_get_ns1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user_USCOREauth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->note_USCOREattachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(soap, &a->note_USCOREattachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note_attachment", -1, &a->note_USCOREattachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *type)
{
	size_t soap_flag_note_USCOREattachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_note_USCOREattachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note_attachment", &a->note_USCOREattachment, "ns1:new_note_attachment"))
				{	soap_flag_note_USCOREattachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_note_USCOREattachment > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment);
	if (soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:new_return_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->file);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREid);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->file);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREid);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "file", -1, &a->file, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_id", -1, &a->related_USCOREmodule_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_name", -1, &a->related_USCOREmodule_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREnote_USCOREattachment *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_file = 1;
	size_t soap_flag_related_USCOREmodule_USCOREid = 1;
	size_t soap_flag_related_USCOREmodule_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_id", &a->related_USCOREmodule_USCOREid, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREid--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_name", &a->related_USCOREmodule_USCOREname, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_filename > 0 || soap_flag_file > 0 || soap_flag_related_USCOREmodule_USCOREid > 0 || soap_flag_related_USCOREmodule_USCOREname > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment);
	if (soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:new_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse))
		soap_serialize_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmodified_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmodified_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmodified_USCORErelationshipsResponse, sizeof(struct ns1__get_USCOREmodified_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag?tag:"ns1:get_modified_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmodified_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modified_USCORErelationship_USCOREresult(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult))
		soap_serialize_ns1__modified_USCORErelationship_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modified_USCORErelationship_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__modified_USCORErelationship_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__modified_USCORErelationship_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__modified_USCORErelationship_USCOREresult(struct soap *soap, const char *tag, struct ns1__modified_USCORErelationship_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__modified_USCORErelationship_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__modified_USCORErelationship_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__modified_USCORErelationship_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__modified_USCORErelationship_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREresult, sizeof(struct ns1__modified_USCORErelationship_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modified_USCORErelationship_USCOREresult(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREresult);
	if (soap_out_PointerTons1__modified_USCORErelationship_USCOREresult(soap, tag?tag:"ns1:modified_relationship_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__modified_USCORErelationship_USCOREresult(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modified_USCORErelationship_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse))
		soap_serialize_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivitiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREupcoming_USCOREactivitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREupcoming_USCOREactivitiesResponse, sizeof(struct ns1__get_USCOREupcoming_USCOREactivitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse);
	if (soap_out_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag?tag:"ns1:get_upcoming_activitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREupcoming_USCOREactivitiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(struct soap *soap, struct ns1__get_USCOREupcoming_USCOREactivitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREupcoming_USCOREactivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToupcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist *const*a)
{
	if (*a)
		soap_serialize_upcoming_USCOREactivities_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToupcoming_USCOREactivities_USCORElist(struct soap *soap, const char *tag, int id, struct upcoming_USCOREactivities_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_upcoming_USCOREactivities_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_upcoming_USCOREactivities_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct upcoming_USCOREactivities_USCORElist ** SOAP_FMAC4 soap_in_PointerToupcoming_USCOREactivities_USCORElist(struct soap *soap, const char *tag, struct upcoming_USCOREactivities_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct upcoming_USCOREactivities_USCORElist **)soap_malloc(soap, sizeof(struct upcoming_USCOREactivities_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_upcoming_USCOREactivities_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct upcoming_USCOREactivities_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_upcoming_USCOREactivities_USCORElist, sizeof(struct upcoming_USCOREactivities_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToupcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToupcoming_USCOREactivities_USCORElist);
	if (soap_out_PointerToupcoming_USCOREactivities_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct upcoming_USCOREactivities_USCORElist ** SOAP_FMAC4 soap_get_PointerToupcoming_USCOREactivities_USCORElist(struct soap *soap, struct upcoming_USCOREactivities_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToupcoming_USCOREactivities_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCORElast_USCOREviewedResponse(struct soap *soap, struct ns1__get_USCORElast_USCOREviewedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse))
		soap_serialize_ns1__get_USCORElast_USCOREviewedResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCORElast_USCOREviewedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCORElast_USCOREviewedResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewedResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCORElast_USCOREviewedResponse(struct soap *soap, const char *tag, struct ns1__get_USCORElast_USCOREviewedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCORElast_USCOREviewedResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCORElast_USCOREviewedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCORElast_USCOREviewedResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElast_USCOREviewedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCORElast_USCOREviewedResponse, sizeof(struct ns1__get_USCORElast_USCOREviewedResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCORElast_USCOREviewedResponse(struct soap *soap, struct ns1__get_USCORElast_USCOREviewedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCORElast_USCOREviewedResponse);
	if (soap_out_PointerTons1__get_USCORElast_USCOREviewedResponse(soap, tag?tag:"ns1:get_last_viewedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORElast_USCOREviewedResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCORElast_USCOREviewedResponse(struct soap *soap, struct ns1__get_USCORElast_USCOREviewedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCORElast_USCOREviewedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomodule_USCOREnames(struct soap *soap, struct module_USCOREnames *const*a)
{
	if (*a)
		soap_serialize_module_USCOREnames(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomodule_USCOREnames(struct soap *soap, const char *tag, int id, struct module_USCOREnames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_module_USCOREnames);
	if (id < 0)
		return soap->error;
	return soap_out_module_USCOREnames(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct module_USCOREnames ** SOAP_FMAC4 soap_in_PointerTomodule_USCOREnames(struct soap *soap, const char *tag, struct module_USCOREnames **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct module_USCOREnames **)soap_malloc(soap, sizeof(struct module_USCOREnames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_module_USCOREnames(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct module_USCOREnames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_module_USCOREnames, sizeof(struct module_USCOREnames), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomodule_USCOREnames(struct soap *soap, struct module_USCOREnames *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomodule_USCOREnames);
	if (soap_out_PointerTomodule_USCOREnames(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct module_USCOREnames ** SOAP_FMAC4 soap_get_PointerTomodule_USCOREnames(struct soap *soap, struct module_USCOREnames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomodule_USCOREnames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolast_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist *const*a)
{
	if (*a)
		soap_serialize_last_USCOREviewed_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolast_USCOREviewed_USCORElist(struct soap *soap, const char *tag, int id, struct last_USCOREviewed_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_last_USCOREviewed_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_last_USCOREviewed_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct last_USCOREviewed_USCORElist ** SOAP_FMAC4 soap_in_PointerTolast_USCOREviewed_USCORElist(struct soap *soap, const char *tag, struct last_USCOREviewed_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct last_USCOREviewed_USCORElist **)soap_malloc(soap, sizeof(struct last_USCOREviewed_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_last_USCOREviewed_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct last_USCOREviewed_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_last_USCOREviewed_USCORElist, sizeof(struct last_USCOREviewed_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolast_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolast_USCOREviewed_USCORElist);
	if (soap_out_PointerTolast_USCOREviewed_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct last_USCOREviewed_USCORElist ** SOAP_FMAC4 soap_get_PointerTolast_USCOREviewed_USCORElist(struct soap *soap, struct last_USCOREviewed_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolast_USCOREviewed_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response))
		soap_serialize_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response, sizeof(struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response);
	if (soap_out_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag?tag:"ns1:get_module_fields_md5Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields_USCOREmd5Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmodule_USCOREfields_USCOREmd5Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomd5_USCOREresults(struct soap *soap, struct md5_USCOREresults *const*a)
{
	if (*a)
		soap_serialize_md5_USCOREresults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomd5_USCOREresults(struct soap *soap, const char *tag, int id, struct md5_USCOREresults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_md5_USCOREresults);
	if (id < 0)
		return soap->error;
	return soap_out_md5_USCOREresults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct md5_USCOREresults ** SOAP_FMAC4 soap_in_PointerTomd5_USCOREresults(struct soap *soap, const char *tag, struct md5_USCOREresults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct md5_USCOREresults **)soap_malloc(soap, sizeof(struct md5_USCOREresults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_md5_USCOREresults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct md5_USCOREresults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_md5_USCOREresults, sizeof(struct md5_USCOREresults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomd5_USCOREresults(struct soap *soap, struct md5_USCOREresults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomd5_USCOREresults);
	if (soap_out_PointerTomd5_USCOREresults(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct md5_USCOREresults ** SOAP_FMAC4 soap_get_PointerTomd5_USCOREresults(struct soap *soap, struct md5_USCOREresults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomd5_USCOREresults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse))
		soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentries_USCOREcountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentries_USCOREcountResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse);
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag?tag:"ns1:get_entries_countResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult))
		soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag?tag:"ns1:get_entries_count_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse))
		soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmergeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse);
	if (soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag?tag:"ns1:set_campaign_mergeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse))
		soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse);
	if (soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag?tag:"ns1:get_available_modulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__module_USCORElist))
		soap_serialize_ns1__module_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__module_USCORElist(struct soap *soap, const char *tag, int id, struct ns1__module_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__module_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__module_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__module_USCORElist ** SOAP_FMAC4 soap_in_PointerTons1__module_USCORElist(struct soap *soap, const char *tag, struct ns1__module_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__module_USCORElist **)soap_malloc(soap, sizeof(struct ns1__module_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__module_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__module_USCORElist, sizeof(struct ns1__module_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__module_USCORElist);
	if (soap_out_PointerTons1__module_USCORElist(soap, tag?tag:"ns1:module_list", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__module_USCORElist ** SOAP_FMAC4 soap_get_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__module_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse))
		soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse ** SOAP_FMAC4 soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmoduleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__search_USCOREby_USCOREmoduleResponse **)soap_malloc(soap, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmoduleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse);
	if (soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag?tag:"ns1:search_by_moduleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse ** SOAP_FMAC4 soap_get_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult))
		soap_serialize_ns1__return_USCOREsearch_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__return_USCOREsearch_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__return_USCOREsearch_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, struct ns1__return_USCOREsearch_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__return_USCOREsearch_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__return_USCOREsearch_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__return_USCOREsearch_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREsearch_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult, sizeof(struct ns1__return_USCOREsearch_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__return_USCOREsearch_USCOREresult);
	if (soap_out_PointerTons1__return_USCOREsearch_USCOREresult(soap, tag?tag:"ns1:return_search_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__return_USCOREsearch_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse))
		soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevisionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREdocument_USCORErevisionResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse);
	if (soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag?tag:"ns1:get_document_revisionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision))
		soap_serialize_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision **)soap_malloc(soap, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision);
	if (soap_out_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag?tag:"ns1:new_return_document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse))
		soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevisionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREdocument_USCORErevisionResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse);
	if (soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag?tag:"ns1:set_document_revisionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse))
		soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachmentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREnote_USCOREattachmentResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse);
	if (soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag?tag:"ns1:get_note_attachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment))
		soap_serialize_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment **)soap_malloc(soap, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment);
	if (soap_out_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:new_return_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse))
		soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachmentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREnote_USCOREattachmentResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse);
	if (soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag?tag:"ns1:set_note_attachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse))
		soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfieldsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse);
	if (soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag?tag:"ns1:get_module_fieldsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields))
		soap_serialize_ns1__new_USCOREmodule_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREmodule_USCOREfields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREmodule_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, struct ns1__new_USCOREmodule_USCOREfields **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREmodule_USCOREfields **)soap_malloc(soap, sizeof(struct ns1__new_USCOREmodule_USCOREfields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREmodule_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREmodule_USCOREfields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields, sizeof(struct ns1__new_USCOREmodule_USCOREfields), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREmodule_USCOREfields);
	if (soap_out_PointerTons1__new_USCOREmodule_USCOREfields(soap, tag?tag:"ns1:new_module_fields", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREmodule_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse))
		soap_serialize_ns1__get_USCOREserver_USCOREinfoResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREserver_USCOREinfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREserver_USCOREinfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREserver_USCOREinfoResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREserver_USCOREinfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREserver_USCOREinfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfoResponse, sizeof(struct ns1__get_USCOREserver_USCOREinfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfoResponse);
	if (soap_out_PointerTons1__get_USCOREserver_USCOREinfoResponse(soap, tag?tag:"ns1:get_server_infoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREserver_USCOREinfoResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREserver_USCOREinfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult))
		soap_serialize_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag?tag:"ns1:get_server_info_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentriesResponse))
		soap_serialize_ns1__set_USCOREentriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentriesResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentriesResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentriesResponse, sizeof(struct ns1__set_USCOREentriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentriesResponse);
	if (soap_out_PointerTons1__set_USCOREentriesResponse(soap, tag?tag:"ns1:set_entriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult))
		soap_serialize_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREset_USCOREentries_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentries_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentries_USCOREresult);
	if (soap_out_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, tag?tag:"ns1:new_set_entries_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentryResponse))
		soap_serialize_ns1__set_USCOREentryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentryResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentryResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentryResponse, sizeof(struct ns1__set_USCOREentryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentryResponse);
	if (soap_out_PointerTons1__set_USCOREentryResponse(soap, tag?tag:"ns1:set_entryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult))
		soap_serialize_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREset_USCOREentry_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentry_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREset_USCOREentry_USCOREresult);
	if (soap_out_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, tag?tag:"ns1:new_set_entry_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse))
		soap_serialize_ns1__get_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, sizeof(struct ns1__get_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__get_USCORErelationshipsResponse(soap, tag?tag:"ns1:get_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse))
		soap_serialize_ns1__set_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, sizeof(struct ns1__set_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__set_USCORErelationshipsResponse(soap, tag?tag:"ns1:set_relationshipsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodeleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray *const*a)
{
	if (*a)
		soap_serialize_deleted_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodeleted_USCOREarray(struct soap *soap, const char *tag, int id, struct deleted_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_deleted_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_deleted_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct deleted_USCOREarray ** SOAP_FMAC4 soap_in_PointerTodeleted_USCOREarray(struct soap *soap, const char *tag, struct deleted_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct deleted_USCOREarray **)soap_malloc(soap, sizeof(struct deleted_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_deleted_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct deleted_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_deleted_USCOREarray, sizeof(struct deleted_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodeleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodeleted_USCOREarray);
	if (soap_out_PointerTodeleted_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct deleted_USCOREarray ** SOAP_FMAC4 soap_get_PointerTodeleted_USCOREarray(struct soap *soap, struct deleted_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodeleted_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonew_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *const*a)
{
	if (*a)
		soap_serialize_new_USCOREset_USCORErelationhip_USCOREids(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonew_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, int id, struct new_USCOREset_USCORErelationhip_USCOREids *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids);
	if (id < 0)
		return soap->error;
	return soap_out_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids ** SOAP_FMAC4 soap_in_PointerTonew_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, struct new_USCOREset_USCORErelationhip_USCOREids **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct new_USCOREset_USCORErelationhip_USCOREids **)soap_malloc(soap, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct new_USCOREset_USCORErelationhip_USCOREids **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonew_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTonew_USCOREset_USCORErelationhip_USCOREids);
	if (soap_out_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids ** SOAP_FMAC4 soap_get_PointerTonew_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTonew_USCOREset_USCORErelationhip_USCOREids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationshipResponse))
		soap_serialize_ns1__set_USCORErelationshipResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationshipResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationshipResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationshipResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationshipResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationshipResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationshipResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationshipResponse, sizeof(struct ns1__set_USCORErelationshipResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse);
	if (soap_out_PointerTons1__set_USCORErelationshipResponse(soap, tag?tag:"ns1:set_relationshipResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationshipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult))
		soap_serialize_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult);
	if (soap_out_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag?tag:"ns1:new_set_relationship_list_result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse))
		soap_serialize_ns1__get_USCOREentry_USCORElistResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCORElistResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElistResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCORElistResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCORElistResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElistResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse);
	if (soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag?tag:"ns1:get_entry_listResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2))
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2);
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag?tag:"ns1:get_entry_list_result_version2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentriesResponse))
		soap_serialize_ns1__get_USCOREentriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentriesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentriesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentriesResponse, sizeof(struct ns1__get_USCOREentriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentriesResponse);
	if (soap_out_PointerTons1__get_USCOREentriesResponse(soap, tag?tag:"ns1:get_entriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentryResponse))
		soap_serialize_ns1__get_USCOREentryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentryResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentryResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentryResponse, sizeof(struct ns1__get_USCOREentryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentryResponse);
	if (soap_out_PointerTons1__get_USCOREentryResponse(soap, tag?tag:"ns1:get_entryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *const*a)
{
	if (*a)
		soap_serialize_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray ** SOAP_FMAC4 soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray **)soap_malloc(soap, sizeof(struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREnames_USCOREto_USCOREfields_USCOREarray, sizeof(struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray ** SOAP_FMAC4 soap_get_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct link_USCOREnames_USCOREto_USCOREfields_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREnames_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2))
		soap_serialize_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2);
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag?tag:"ns1:get_entry_result_version2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logoutResponse))
		soap_serialize_ns1__logoutResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id, struct ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__logoutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag, struct ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__logoutResponse **)soap_malloc(soap, sizeof(struct ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__logoutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(struct ns1__logoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logoutResponse);
	if (soap_out_PointerTons1__logoutResponse(soap, tag?tag:"ns1:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginResponse))
		soap_serialize_ns1__loginResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginResponse(struct soap *soap, const char *tag, int id, struct ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__loginResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTons1__loginResponse(struct soap *soap, const char *tag, struct ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__loginResponse **)soap_malloc(soap, sizeof(struct ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__loginResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginResponse, sizeof(struct ns1__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginResponse);
	if (soap_out_PointerTons1__loginResponse(soap, tag?tag:"ns1:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user_USCOREauth))
		soap_serialize_ns1__user_USCOREauth(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user_USCOREauth(struct soap *soap, const char *tag, int id, struct ns1__user_USCOREauth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user_USCOREauth);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__user_USCOREauth(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__user_USCOREauth ** SOAP_FMAC4 soap_in_PointerTons1__user_USCOREauth(struct soap *soap, const char *tag, struct ns1__user_USCOREauth **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__user_USCOREauth **)soap_malloc(soap, sizeof(struct ns1__user_USCOREauth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__user_USCOREauth(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREauth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user_USCOREauth, sizeof(struct ns1__user_USCOREauth), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user_USCOREauth);
	if (soap_out_PointerTons1__user_USCOREauth(soap, tag?tag:"ns1:user_auth", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__user_USCOREauth ** SOAP_FMAC4 soap_get_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user_USCOREauth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry))
		soap_serialize_PointerTons1__modified_USCORErelationship_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__modified_USCORErelationship_USCOREentry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry *** SOAP_FMAC4 soap_in_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, struct ns1__modified_USCORErelationship_USCOREentry ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__modified_USCORErelationship_USCOREentry ***)soap_malloc(soap, sizeof(struct ns1__modified_USCORErelationship_USCOREentry **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__modified_USCORErelationship_USCOREentry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry, sizeof(struct ns1__modified_USCORErelationship_USCOREentry *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__modified_USCORErelationship_USCOREentry);
	if (soap_out_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(soap, tag?tag:"ns1:modified_relationship_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry *** SOAP_FMAC4 soap_get_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry))
		soap_serialize_ns1__modified_USCORErelationship_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__modified_USCORErelationship_USCOREentry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__modified_USCORErelationship_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry ** SOAP_FMAC4 soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, const char *tag, struct ns1__modified_USCORErelationship_USCOREentry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__modified_USCORErelationship_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__modified_USCORErelationship_USCOREentry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__modified_USCORErelationship_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__modified_USCORErelationship_USCOREentry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modified_USCORErelationship_USCOREentry, sizeof(struct ns1__modified_USCORErelationship_USCOREentry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modified_USCORErelationship_USCOREentry);
	if (soap_out_PointerTons1__modified_USCORErelationship_USCOREentry(soap, tag?tag:"ns1:modified_relationship_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modified_USCORErelationship_USCOREentry ** SOAP_FMAC4 soap_get_PointerTons1__modified_USCORErelationship_USCOREentry(struct soap *soap, struct ns1__modified_USCORErelationship_USCOREentry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modified_USCORErelationship_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTolink_USCOREvalue))
		soap_serialize_PointerTolink_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTolink_USCOREvalue(struct soap *soap, const char *tag, int id, struct link_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTolink_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTolink_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTolink_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREvalue ***)soap_malloc(soap, sizeof(struct link_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTolink_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTolink_USCOREvalue, sizeof(struct link_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTolink_USCOREvalue);
	if (soap_out_PointerToPointerTolink_USCOREvalue(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTolink_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue))
		soap_serialize_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__search_USCORElink_USCOREname_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__search_USCORElink_USCOREname_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue);
	if (soap_out_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag?tag:"ns1:search_link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue))
		soap_serialize_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__search_USCORElink_USCOREname_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__search_USCORElink_USCOREname_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCORElink_USCOREname_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__search_USCORElink_USCOREname_USCOREvalue, sizeof(struct ns1__search_USCORElink_USCOREname_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__search_USCORElink_USCOREname_USCOREvalue);
	if (soap_out_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag?tag:"ns1:search_link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__search_USCORElink_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(struct soap *soap, struct ns1__search_USCORElink_USCOREname_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__search_USCORElink_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__entry_USCORElist2))
		soap_serialize_PointerTons1__entry_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__entry_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__entry_USCORElist2 **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__entry_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__entry_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 *** SOAP_FMAC4 soap_in_PointerToPointerTons1__entry_USCORElist2(struct soap *soap, const char *tag, struct ns1__entry_USCORElist2 ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCORElist2 ***)soap_malloc(soap, sizeof(struct ns1__entry_USCORElist2 **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__entry_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCORElist2 ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__entry_USCORElist2, sizeof(struct ns1__entry_USCORElist2 *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__entry_USCORElist2);
	if (soap_out_PointerToPointerTons1__entry_USCORElist2(soap, tag?tag:"ns1:entry_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 *** SOAP_FMAC4 soap_get_PointerToPointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__entry_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__entry_USCORElist2))
		soap_serialize_ns1__entry_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entry_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__entry_USCORElist2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__entry_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__entry_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 ** SOAP_FMAC4 soap_in_PointerTons1__entry_USCORElist2(struct soap *soap, const char *tag, struct ns1__entry_USCORElist2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__entry_USCORElist2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__entry_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCORElist2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entry_USCORElist2, sizeof(struct ns1__entry_USCORElist2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__entry_USCORElist2);
	if (soap_out_PointerTons1__entry_USCORElist2(soap, tag?tag:"ns1:entry_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCORElist2 ** SOAP_FMAC4 soap_get_PointerTons1__entry_USCORElist2(struct soap *soap, struct ns1__entry_USCORElist2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__entry_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__field_USCORElist2))
		soap_serialize_PointerTons1__field_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__field_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__field_USCORElist2 **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__field_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__field_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 *** SOAP_FMAC4 soap_in_PointerToPointerTons1__field_USCORElist2(struct soap *soap, const char *tag, struct ns1__field_USCORElist2 ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field_USCORElist2 ***)soap_malloc(soap, sizeof(struct ns1__field_USCORElist2 **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__field_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field_USCORElist2 ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__field_USCORElist2, sizeof(struct ns1__field_USCORElist2 *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__field_USCORElist2);
	if (soap_out_PointerToPointerTons1__field_USCORElist2(soap, tag?tag:"ns1:field_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 *** SOAP_FMAC4 soap_get_PointerToPointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__field_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__field_USCORElist2))
		soap_serialize_ns1__field_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__field_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__field_USCORElist2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__field_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__field_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 ** SOAP_FMAC4 soap_in_PointerTons1__field_USCORElist2(struct soap *soap, const char *tag, struct ns1__field_USCORElist2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__field_USCORElist2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__field_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field_USCORElist2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__field_USCORElist2, sizeof(struct ns1__field_USCORElist2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__field_USCORElist2);
	if (soap_out_PointerTons1__field_USCORElist2(soap, tag?tag:"ns1:field_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field_USCORElist2 ** SOAP_FMAC4 soap_get_PointerTons1__field_USCORElist2(struct soap *soap, struct ns1__field_USCORElist2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__field_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry))
		soap_serialize_PointerTons1__acl_USCORElist_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__acl_USCORElist_USCOREentry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__acl_USCORElist_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry *** SOAP_FMAC4 soap_in_PointerToPointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__acl_USCORElist_USCOREentry ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__acl_USCORElist_USCOREentry ***)soap_malloc(soap, sizeof(struct ns1__acl_USCORElist_USCOREentry **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__acl_USCORElist_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__acl_USCORElist_USCOREentry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry, sizeof(struct ns1__acl_USCORElist_USCOREentry *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__acl_USCORElist_USCOREentry);
	if (soap_out_PointerToPointerTons1__acl_USCORElist_USCOREentry(soap, tag?tag:"ns1:acl_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry *** SOAP_FMAC4 soap_get_PointerToPointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__acl_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry))
		soap_serialize_ns1__acl_USCORElist_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__acl_USCORElist_USCOREentry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__acl_USCORElist_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry ** SOAP_FMAC4 soap_in_PointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__acl_USCORElist_USCOREentry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__acl_USCORElist_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__acl_USCORElist_USCOREentry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__acl_USCORElist_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__acl_USCORElist_USCOREentry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__acl_USCORElist_USCOREentry, sizeof(struct ns1__acl_USCORElist_USCOREentry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__acl_USCORElist_USCOREentry);
	if (soap_out_PointerTons1__acl_USCORElist_USCOREentry(soap, tag?tag:"ns1:acl_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__acl_USCORElist_USCOREentry ** SOAP_FMAC4 soap_get_PointerTons1__acl_USCORElist_USCOREentry(struct soap *soap, struct ns1__acl_USCORElist_USCOREentry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__acl_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry))
		soap_serialize_PointerTons1__module_USCORElist_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__module_USCORElist_USCOREentry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__module_USCORElist_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry *** SOAP_FMAC4 soap_in_PointerToPointerTons1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__module_USCORElist_USCOREentry ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__module_USCORElist_USCOREentry ***)soap_malloc(soap, sizeof(struct ns1__module_USCORElist_USCOREentry **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__module_USCORElist_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist_USCOREentry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry, sizeof(struct ns1__module_USCORElist_USCOREentry *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__module_USCORElist_USCOREentry);
	if (soap_out_PointerToPointerTons1__module_USCORElist_USCOREentry(soap, tag?tag:"ns1:module_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry *** SOAP_FMAC4 soap_get_PointerToPointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__module_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__module_USCORElist_USCOREentry))
		soap_serialize_ns1__module_USCORElist_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__module_USCORElist_USCOREentry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__module_USCORElist_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__module_USCORElist_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry ** SOAP_FMAC4 soap_in_PointerTons1__module_USCORElist_USCOREentry(struct soap *soap, const char *tag, struct ns1__module_USCORElist_USCOREentry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__module_USCORElist_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__module_USCORElist_USCOREentry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__module_USCORElist_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist_USCOREentry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__module_USCORElist_USCOREentry, sizeof(struct ns1__module_USCORElist_USCOREentry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__module_USCORElist_USCOREentry);
	if (soap_out_PointerTons1__module_USCORElist_USCOREentry(soap, tag?tag:"ns1:module_list_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__module_USCORElist_USCOREentry ** SOAP_FMAC4 soap_get_PointerTons1__module_USCORElist_USCOREentry(struct soap *soap, struct ns1__module_USCORElist_USCOREentry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__module_USCORElist_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry))
		soap_serialize_PointerTons1__last_USCOREviewed_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__last_USCOREviewed_USCOREentry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__last_USCOREviewed_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry *** SOAP_FMAC4 soap_in_PointerToPointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, struct ns1__last_USCOREviewed_USCOREentry ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__last_USCOREviewed_USCOREentry ***)soap_malloc(soap, sizeof(struct ns1__last_USCOREviewed_USCOREentry **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__last_USCOREviewed_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__last_USCOREviewed_USCOREentry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry, sizeof(struct ns1__last_USCOREviewed_USCOREentry *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__last_USCOREviewed_USCOREentry);
	if (soap_out_PointerToPointerTons1__last_USCOREviewed_USCOREentry(soap, tag?tag:"ns1:last_viewed_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry *** SOAP_FMAC4 soap_get_PointerToPointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__last_USCOREviewed_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry))
		soap_serialize_ns1__last_USCOREviewed_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__last_USCOREviewed_USCOREentry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__last_USCOREviewed_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry ** SOAP_FMAC4 soap_in_PointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, const char *tag, struct ns1__last_USCOREviewed_USCOREentry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__last_USCOREviewed_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__last_USCOREviewed_USCOREentry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__last_USCOREviewed_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__last_USCOREviewed_USCOREentry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__last_USCOREviewed_USCOREentry, sizeof(struct ns1__last_USCOREviewed_USCOREentry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__last_USCOREviewed_USCOREentry);
	if (soap_out_PointerTons1__last_USCOREviewed_USCOREentry(soap, tag?tag:"ns1:last_viewed_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__last_USCOREviewed_USCOREentry ** SOAP_FMAC4 soap_get_PointerTons1__last_USCOREviewed_USCOREentry(struct soap *soap, struct ns1__last_USCOREviewed_USCOREentry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__last_USCOREviewed_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry))
		soap_serialize_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__upcoming_USCOREactivity_USCOREentry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry *** SOAP_FMAC4 soap_in_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, struct ns1__upcoming_USCOREactivity_USCOREentry ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__upcoming_USCOREactivity_USCOREentry ***)soap_malloc(soap, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__upcoming_USCOREactivity_USCOREentry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry);
	if (soap_out_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag?tag:"ns1:upcoming_activity_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry *** SOAP_FMAC4 soap_get_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry))
		soap_serialize_ns1__upcoming_USCOREactivity_USCOREentry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, int id, struct ns1__upcoming_USCOREactivity_USCOREentry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__upcoming_USCOREactivity_USCOREentry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry ** SOAP_FMAC4 soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, const char *tag, struct ns1__upcoming_USCOREactivity_USCOREentry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__upcoming_USCOREactivity_USCOREentry **)soap_malloc(soap, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__upcoming_USCOREactivity_USCOREentry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__upcoming_USCOREactivity_USCOREentry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__upcoming_USCOREactivity_USCOREentry, sizeof(struct ns1__upcoming_USCOREactivity_USCOREentry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__upcoming_USCOREactivity_USCOREentry);
	if (soap_out_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag?tag:"ns1:upcoming_activity_entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__upcoming_USCOREactivity_USCOREentry ** SOAP_FMAC4 soap_get_PointerTons1__upcoming_USCOREactivity_USCOREentry(struct soap *soap, struct ns1__upcoming_USCOREactivity_USCOREentry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__upcoming_USCOREactivity_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToselect_USCOREfields))
		soap_serialize_PointerToselect_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToselect_USCOREfields(struct soap *soap, const char *tag, int id, struct select_USCOREfields **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToselect_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToselect_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct select_USCOREfields *** SOAP_FMAC4 soap_in_PointerToPointerToselect_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct select_USCOREfields ***)soap_malloc(soap, sizeof(struct select_USCOREfields **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToselect_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToselect_USCOREfields, sizeof(struct select_USCOREfields *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToselect_USCOREfields);
	if (soap_out_PointerToPointerToselect_USCOREfields(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct select_USCOREfields *** SOAP_FMAC4 soap_get_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToselect_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCORElist2))
		soap_serialize_PointerTons1__link_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__link_USCORElist2 **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCORElist2(struct soap *soap, const char *tag, struct ns1__link_USCORElist2 ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCORElist2 ***)soap_malloc(soap, sizeof(struct ns1__link_USCORElist2 **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCORElist2 ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCORElist2, sizeof(struct ns1__link_USCORElist2 *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCORElist2);
	if (soap_out_PointerToPointerTons1__link_USCORElist2(soap, tag?tag:"ns1:link_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCORElist2))
		soap_serialize_ns1__link_USCORElist2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCORElist2(struct soap *soap, const char *tag, int id, struct ns1__link_USCORElist2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCORElist2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCORElist2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 ** SOAP_FMAC4 soap_in_PointerTons1__link_USCORElist2(struct soap *soap, const char *tag, struct ns1__link_USCORElist2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCORElist2 **)soap_malloc(soap, sizeof(struct ns1__link_USCORElist2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCORElist2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCORElist2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCORElist2, sizeof(struct ns1__link_USCORElist2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCORElist2);
	if (soap_out_PointerTons1__link_USCORElist2(soap, tag?tag:"ns1:link_list2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCORElist2 ** SOAP_FMAC4 soap_get_PointerTons1__link_USCORElist2(struct soap *soap, struct ns1__link_USCORElist2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCORElist2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue))
		soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue);
	if (soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag?tag:"ns1:link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue))
		soap_serialize_ns1__link_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue);
	if (soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag?tag:"ns1:link_name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREvalue2))
		soap_serialize_PointerTons1__link_USCOREvalue2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREvalue2(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREvalue2 **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREvalue2);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREvalue2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREvalue2(struct soap *soap, const char *tag, struct ns1__link_USCOREvalue2 ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREvalue2 ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREvalue2 **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREvalue2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREvalue2 ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREvalue2, sizeof(struct ns1__link_USCOREvalue2 *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREvalue2);
	if (soap_out_PointerToPointerTons1__link_USCOREvalue2(soap, tag?tag:"ns1:link_value2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREvalue2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREvalue2))
		soap_serialize_ns1__link_USCOREvalue2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREvalue2(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREvalue2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREvalue2);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREvalue2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREvalue2(struct soap *soap, const char *tag, struct ns1__link_USCOREvalue2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREvalue2 **)soap_malloc(soap, sizeof(struct ns1__link_USCOREvalue2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREvalue2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREvalue2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREvalue2, sizeof(struct ns1__link_USCOREvalue2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREvalue2);
	if (soap_out_PointerTons1__link_USCOREvalue2(soap, tag?tag:"ns1:link_value2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREvalue2 ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREvalue2(struct soap *soap, struct ns1__link_USCOREvalue2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREvalue2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray))
		soap_serialize_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag?tag:"ns1:link_name_to_fields_array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray))
		soap_serialize_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag?tag:"ns1:link_name_to_fields_array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__entry_USCOREvalue))
		soap_serialize_PointerTons1__entry_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__entry_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__entry_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__entry_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__entry_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue);
	if (soap_out_PointerToPointerTons1__entry_USCOREvalue(soap, tag?tag:"ns1:entry_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__entry_USCOREvalue))
		soap_serialize_ns1__entry_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__entry_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__entry_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__entry_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__entry_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__entry_USCOREvalue);
	if (soap_out_PointerTons1__entry_USCOREvalue(soap, tag?tag:"ns1:entry_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist))
		soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElist **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist *** SOAP_FMAC4 soap_in_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElist ***)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToname_USCOREvalue_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist);
	if (soap_out_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist *** SOAP_FMAC4 soap_get_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__name_USCOREvalue))
		soap_serialize_PointerTons1__name_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__name_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__name_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__name_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue);
	if (soap_out_PointerToPointerTons1__name_USCOREvalue(soap, tag?tag:"ns1:name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__name_USCOREvalue))
		soap_serialize_ns1__name_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__name_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__name_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__name_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__name_USCOREvalue);
	if (soap_out_PointerTons1__name_USCOREvalue(soap, tag?tag:"ns1:name_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREfield))
		soap_serialize_PointerTons1__link_USCOREfield(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREfield(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREfield **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREfield);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREfield(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREfield *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREfield ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREfield(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREfield);
	if (soap_out_PointerToPointerTons1__link_USCOREfield(soap, tag?tag:"ns1:link_field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREfield *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREfield))
		soap_serialize_ns1__link_USCOREfield(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREfield(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREfield *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREfield);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREfield(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREfield ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREfield **)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREfield(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREfield);
	if (soap_out_PointerTons1__link_USCOREfield(soap, tag?tag:"ns1:link_field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__link_USCOREfield ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__field(struct soap *soap, struct ns1__field **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__field))
		soap_serialize_PointerTons1__field(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__field(struct soap *soap, const char *tag, int id, struct ns1__field **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__field);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__field(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field *** SOAP_FMAC4 soap_in_PointerToPointerTons1__field(struct soap *soap, const char *tag, struct ns1__field ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field ***)soap_malloc(soap, sizeof(struct ns1__field **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__field(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__field, sizeof(struct ns1__field *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__field(struct soap *soap, struct ns1__field **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__field);
	if (soap_out_PointerToPointerTons1__field(soap, tag?tag:"ns1:field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field *** SOAP_FMAC4 soap_get_PointerToPointerTons1__field(struct soap *soap, struct ns1__field ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__field(struct soap *soap, struct ns1__field *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__field))
		soap_serialize_ns1__field(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__field(struct soap *soap, const char *tag, int id, struct ns1__field *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__field);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__field(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field ** SOAP_FMAC4 soap_in_PointerTons1__field(struct soap *soap, const char *tag, struct ns1__field **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field **)soap_malloc(soap, sizeof(struct ns1__field *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__field(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__field, sizeof(struct ns1__field), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__field(struct soap *soap, struct ns1__field *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__field);
	if (soap_out_PointerTons1__field(soap, tag?tag:"ns1:field", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__field ** SOAP_FMAC4 soap_get_PointerTons1__field(struct soap *soap, struct ns1__field **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__error_USCOREvalue))
		soap_serialize_ns1__error_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__error_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__error_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__error_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__error_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__error_USCOREvalue(struct soap *soap, const char *tag, struct ns1__error_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__error_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__error_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__error_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__error_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__error_USCOREvalue, sizeof(struct ns1__error_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__error_USCOREvalue);
	if (soap_out_PointerTons1__error_USCOREvalue(soap, tag?tag:"ns1:error_value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__error_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist *const*a)
{
	if (*a)
		soap_serialize_modified_USCORErelationship_USCOREentry_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, const char *tag, int id, struct modified_USCORErelationship_USCOREentry_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_modified_USCORErelationship_USCOREentry_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct modified_USCORErelationship_USCOREentry_USCORElist ** SOAP_FMAC4 soap_in_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, const char *tag, struct modified_USCORErelationship_USCOREentry_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct modified_USCORErelationship_USCOREentry_USCORElist **)soap_malloc(soap, sizeof(struct modified_USCORErelationship_USCOREentry_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_modified_USCORErelationship_USCOREentry_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct modified_USCORErelationship_USCOREentry_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_modified_USCORErelationship_USCOREentry_USCORElist, sizeof(struct modified_USCORErelationship_USCOREentry_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomodified_USCORErelationship_USCOREentry_USCORElist);
	if (soap_out_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct modified_USCORErelationship_USCOREentry_USCORElist ** SOAP_FMAC4 soap_get_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(struct soap *soap, struct modified_USCORErelationship_USCOREentry_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomodified_USCORErelationship_USCOREentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosearch_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist *const*a)
{
	if (*a)
		soap_serialize_search_USCORElink_USCOREarray_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosearch_USCORElink_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, struct search_USCORElink_USCOREarray_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_search_USCORElink_USCOREarray_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct search_USCORElink_USCOREarray_USCORElist ** SOAP_FMAC4 soap_in_PointerTosearch_USCORElink_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct search_USCORElink_USCOREarray_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct search_USCORElink_USCOREarray_USCORElist **)soap_malloc(soap, sizeof(struct search_USCORElink_USCOREarray_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_search_USCORElink_USCOREarray_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct search_USCORElink_USCOREarray_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_search_USCORElink_USCOREarray_USCORElist, sizeof(struct search_USCORElink_USCOREarray_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosearch_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosearch_USCORElink_USCOREarray_USCORElist);
	if (soap_out_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct search_USCORElink_USCOREarray_USCORElist ** SOAP_FMAC4 soap_get_PointerTosearch_USCORElink_USCOREarray_USCORElist(struct soap *soap, struct search_USCORElink_USCOREarray_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosearch_USCORElink_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue *const*a)
{
	if (*a)
		soap_serialize_link_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREvalue(struct soap *soap, const char *tag, int id, struct link_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTolink_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREvalue **)soap_malloc(soap, sizeof(struct link_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREvalue, sizeof(struct link_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREvalue);
	if (soap_out_PointerTolink_USCOREvalue(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCORElist(struct soap *soap, const char *tag, struct link_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCORElist **)soap_malloc(soap, sizeof(struct link_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCORElist, sizeof(struct link_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCORElist);
	if (soap_out_PointerTolink_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacl_USCORElist(struct soap *soap, struct acl_USCORElist *const*a)
{
	if (*a)
		soap_serialize_acl_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacl_USCORElist(struct soap *soap, const char *tag, int id, struct acl_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_acl_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_acl_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acl_USCORElist ** SOAP_FMAC4 soap_in_PointerToacl_USCORElist(struct soap *soap, const char *tag, struct acl_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acl_USCORElist **)soap_malloc(soap, sizeof(struct acl_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acl_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acl_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acl_USCORElist, sizeof(struct acl_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacl_USCORElist(struct soap *soap, struct acl_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacl_USCORElist);
	if (soap_out_PointerToacl_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct acl_USCORElist ** SOAP_FMAC4 soap_get_PointerToacl_USCORElist(struct soap *soap, struct acl_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacl_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomodule_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray *const*a)
{
	if (*a)
		soap_serialize_module_USCORElist_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomodule_USCORElist_USCOREarray(struct soap *soap, const char *tag, int id, struct module_USCORElist_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_module_USCORElist_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_module_USCORElist_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct module_USCORElist_USCOREarray ** SOAP_FMAC4 soap_in_PointerTomodule_USCORElist_USCOREarray(struct soap *soap, const char *tag, struct module_USCORElist_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct module_USCORElist_USCOREarray **)soap_malloc(soap, sizeof(struct module_USCORElist_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_module_USCORElist_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct module_USCORElist_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_module_USCORElist_USCOREarray, sizeof(struct module_USCORElist_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomodule_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomodule_USCORElist_USCOREarray);
	if (soap_out_PointerTomodule_USCORElist_USCOREarray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct module_USCORElist_USCOREarray ** SOAP_FMAC4 soap_get_PointerTomodule_USCORElist_USCOREarray(struct soap *soap, struct module_USCORElist_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomodule_USCORElist_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__document_USCORErevision))
		soap_serialize_ns1__document_USCORErevision(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__document_USCORErevision(struct soap *soap, const char *tag, int id, struct ns1__document_USCORErevision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__document_USCORErevision);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__document_USCORErevision(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__document_USCORErevision ** SOAP_FMAC4 soap_in_PointerTons1__document_USCORErevision(struct soap *soap, const char *tag, struct ns1__document_USCORErevision **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__document_USCORErevision **)soap_malloc(soap, sizeof(struct ns1__document_USCORErevision *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__document_USCORErevision(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__document_USCORErevision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__document_USCORErevision, sizeof(struct ns1__document_USCORErevision), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__document_USCORErevision);
	if (soap_out_PointerTons1__document_USCORErevision(soap, tag?tag:"ns1:document_revision", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__document_USCORErevision ** SOAP_FMAC4 soap_get_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__document_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosearch_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist *const*a)
{
	if (*a)
		soap_serialize_search_USCORElink_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosearch_USCORElink_USCORElist(struct soap *soap, const char *tag, int id, struct search_USCORElink_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_search_USCORElink_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_search_USCORElink_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct search_USCORElink_USCORElist ** SOAP_FMAC4 soap_in_PointerTosearch_USCORElink_USCORElist(struct soap *soap, const char *tag, struct search_USCORElink_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct search_USCORElink_USCORElist **)soap_malloc(soap, sizeof(struct search_USCORElink_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_search_USCORElink_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct search_USCORElink_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_search_USCORElink_USCORElist, sizeof(struct search_USCORElink_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosearch_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosearch_USCORElink_USCORElist);
	if (soap_out_PointerTosearch_USCORElink_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct search_USCORElink_USCORElist ** SOAP_FMAC4 soap_get_PointerTosearch_USCORElink_USCORElist(struct soap *soap, struct search_USCORElink_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosearch_USCORElink_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists *const*a)
{
	if (*a)
		soap_serialize_link_USCORElists(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCORElists(struct soap *soap, const char *tag, int id, struct link_USCORElists *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCORElists);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCORElists(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCORElists ** SOAP_FMAC4 soap_in_PointerTolink_USCORElists(struct soap *soap, const char *tag, struct link_USCORElists **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCORElists **)soap_malloc(soap, sizeof(struct link_USCORElists *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCORElists(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCORElists **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCORElists, sizeof(struct link_USCORElists), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCORElists);
	if (soap_out_PointerTolink_USCORElists(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCORElists ** SOAP_FMAC4 soap_get_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist *const*a)
{
	if (*a)
		soap_serialize_entry_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToentry_USCORElist(struct soap *soap, const char *tag, int id, struct entry_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_entry_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_entry_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct entry_USCORElist ** SOAP_FMAC4 soap_in_PointerToentry_USCORElist(struct soap *soap, const char *tag, struct entry_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct entry_USCORElist **)soap_malloc(soap, sizeof(struct entry_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_entry_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct entry_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_entry_USCORElist, sizeof(struct entry_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToentry_USCORElist);
	if (soap_out_PointerToentry_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct entry_USCORElist ** SOAP_FMAC4 soap_get_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCOREarray_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCOREarray_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREarray_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct link_USCOREarray_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREarray_USCORElist **)soap_malloc(soap, sizeof(struct link_USCOREarray_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREarray_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREarray_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREarray_USCORElist, sizeof(struct link_USCOREarray_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREarray_USCORElist);
	if (soap_out_PointerTolink_USCOREarray_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields *const*a)
{
	if (*a)
		soap_serialize_select_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToselect_USCOREfields(struct soap *soap, const char *tag, int id, struct select_USCOREfields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_select_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_select_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct select_USCOREfields ** SOAP_FMAC4 soap_in_PointerToselect_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct select_USCOREfields **)soap_malloc(soap, sizeof(struct select_USCOREfields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_select_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_select_USCOREfields, sizeof(struct select_USCOREfields), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToselect_USCOREfields);
	if (soap_out_PointerToselect_USCOREfields(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct select_USCOREfields ** SOAP_FMAC4 soap_get_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToselect_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *const*a)
{
	if (*a)
		soap_serialize_name_USCOREvalue_USCORElists(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToname_USCOREvalue_USCORElists(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElists *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (id < 0)
		return soap->error;
	return soap_out_name_USCOREvalue_USCORElists(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists ** SOAP_FMAC4 soap_in_PointerToname_USCOREvalue_USCORElists(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElists **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElists **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElists *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_name_USCOREvalue_USCORElists(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElists **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_name_USCOREvalue_USCORElists, sizeof(struct name_USCOREvalue_USCORElists), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToname_USCOREvalue_USCORElists);
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists ** SOAP_FMAC4 soap_get_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToname_USCOREvalue_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCOREfield_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREfield_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCOREfield_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREfield_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCOREfield_USCORElist(struct soap *soap, const char *tag, struct link_USCOREfield_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREfield_USCORElist **)soap_malloc(soap, sizeof(struct link_USCOREfield_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREfield_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREfield_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREfield_USCORElist, sizeof(struct link_USCOREfield_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREfield_USCORElist);
	if (soap_out_PointerTolink_USCOREfield_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREfield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist *const*a)
{
	if (*a)
		soap_serialize_field_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofield_USCORElist(struct soap *soap, const char *tag, int id, struct field_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_field_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_field_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct field_USCORElist ** SOAP_FMAC4 soap_in_PointerTofield_USCORElist(struct soap *soap, const char *tag, struct field_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct field_USCORElist **)soap_malloc(soap, sizeof(struct field_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_field_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct field_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_field_USCORElist, sizeof(struct field_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofield_USCORElist);
	if (soap_out_PointerTofield_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct field_USCORElist ** SOAP_FMAC4 soap_get_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *const*a)
{
	if (*a)
		soap_serialize_name_USCOREvalue_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_name_USCOREvalue_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist ** SOAP_FMAC4 soap_in_PointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_name_USCOREvalue_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_name_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist);
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist ** SOAP_FMAC4 soap_get_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToname_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment))
		soap_serialize_ns1__new_USCOREnote_USCOREattachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREnote_USCOREattachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREnote_USCOREattachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREnote_USCOREattachment **)soap_malloc(soap, sizeof(struct ns1__new_USCOREnote_USCOREattachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREnote_USCOREattachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREnote_USCOREattachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment);
	if (soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag?tag:"ns1:new_note_attachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
